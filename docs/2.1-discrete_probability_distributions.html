<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Discrete Probability Distributions – Statistics for Engineers in a Hurry (an Illustrated Primer)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e8e9342e845377dfc7513ec3bb59cd67.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<meta name="shinylive:serviceworker_dir" content=".">
<script src="site_libs/quarto-contrib/shinylive-0.9.3/shinylive/load-shinylive-sw.js" type="module"></script>
<script src="site_libs/quarto-contrib/shinylive-0.9.3/shinylive/run-python-blocks.js" type="module"></script>
<link href="site_libs/quarto-contrib/shinylive-0.9.3/shinylive/shinylive.css" rel="stylesheet">
<link href="site_libs/quarto-contrib/shinylive-quarto-css/shinylive-quarto.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Statistics for Engineers in a Hurry (an Illustrated Primer)</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./2-data_generation.html">Probability of Data</a></li><li class="breadcrumb-item"><a href="./2.1-discrete_probability_distributions.html">Discrete Probability Distributions</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./2-data_generation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Probability of Data</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2.1-discrete_probability_distributions.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Discrete Probability Distributions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2.2-continuous-probability-distributions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Continuous Probability Distributions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2.3-statistical_models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Statistical Models</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2.4-machine_learning.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Machine Learning</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./3-parameter_estimation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Likelihood of Model</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3.1-without_priors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Without Priors</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3.2-with_priors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">With Priors</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#preview" id="toc-preview" class="nav-link active" data-scroll-target="#preview">Preview</a></li>
  <li><a href="#models-of-discrete-data-generating-processes" id="toc-models-of-discrete-data-generating-processes" class="nav-link" data-scroll-target="#models-of-discrete-data-generating-processes">Models of Discrete Data Generating Processes</a>
  <ul class="collapse">
  <li><a href="#a-dice-total-model" id="toc-a-dice-total-model" class="nav-link" data-scroll-target="#a-dice-total-model">A Dice Total Model</a></li>
  <li><a href="#discrete-probability-distributions-as-models-of-data-generating-processes" id="toc-discrete-probability-distributions-as-models-of-data-generating-processes" class="nav-link" data-scroll-target="#discrete-probability-distributions-as-models-of-data-generating-processes">Discrete Probability Distributions as Models of Data Generating Processes</a></li>
  </ul></li>
  <li><a href="#probability-of-data" id="toc-probability-of-data" class="nav-link" data-scroll-target="#probability-of-data">Probability of Data</a>
  <ul class="collapse">
  <li><a href="#dice-totals-probability-of-data" id="toc-dice-totals-probability-of-data" class="nav-link" data-scroll-target="#dice-totals-probability-of-data">Dice Totals Probability of Data</a></li>
  <li><a href="#exact-probabilities-from-a-discrete-probability-distribution" id="toc-exact-probabilities-from-a-discrete-probability-distribution" class="nav-link" data-scroll-target="#exact-probabilities-from-a-discrete-probability-distribution">Exact Probabilities from a Discrete Probability Distribution</a></li>
  <li><a href="#probability-of-multiple-events" id="toc-probability-of-multiple-events" class="nav-link" data-scroll-target="#probability-of-multiple-events">Probability of Multiple Events</a></li>
  <li><a href="#calculating-the-relative-probability-of-multiple-events" id="toc-calculating-the-relative-probability-of-multiple-events" class="nav-link" data-scroll-target="#calculating-the-relative-probability-of-multiple-events">Calculating the Relative Probability of Multiple Events</a></li>
  </ul></li>
  <li><a href="#appendix-on-probability-distributions" id="toc-appendix-on-probability-distributions" class="nav-link" data-scroll-target="#appendix-on-probability-distributions">Appendix on Probability Distributions</a>
  <ul class="collapse">
  <li><a href="#joint-discrete-probability-distributions" id="toc-joint-discrete-probability-distributions" class="nav-link" data-scroll-target="#joint-discrete-probability-distributions">Joint Discrete Probability Distributions</a></li>
  <li><a href="#conditional-discrete-probability-distributions" id="toc-conditional-discrete-probability-distributions" class="nav-link" data-scroll-target="#conditional-discrete-probability-distributions">Conditional Discrete Probability Distributions</a></li>
  <li><a href="#marginal-discrete-probability-distributions" id="toc-marginal-discrete-probability-distributions" class="nav-link" data-scroll-target="#marginal-discrete-probability-distributions">Marginal Discrete Probability Distributions</a></li>
  <li><a href="#summary-app" id="toc-summary-app" class="nav-link" data-scroll-target="#summary-app">Summary App</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./2-data_generation.html">Probability of Data</a></li><li class="breadcrumb-item"><a href="./2.1-discrete_probability_distributions.html">Discrete Probability Distributions</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Discrete Probability Distributions</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="preview" class="level2">
<h2 class="anchored" data-anchor-id="preview">Preview</h2>
<p>In the first half of the primer we focus on <span class="math inline">\(P(D|M)\)</span>, the probability of the <span style="text-decoration: underline;">data</span> given a static <span style="text-decoration: underline;">model</span> of a data generating process<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. This first chapter considers only processes with discrete (in contrast with continuous) outputs. We use dice as our first example as it is hopefully an intuitive subject. We then introduce <em>discrete probability distributions</em> as models of other idealized processes. For the first half of the primer we will not question our models, we will consider them as set/frozen and just allow them to generate data for us, assuming that they represent the data generating process of interest.</p>
<p>Once we have have some discussion of models under our belt, we will change our focus to the probability of data. For any model we can use the relative frequency of an event to approximate the events probability. We will show how the accuracy of this probability estimate increases with the number of samples. Where an analytical solution of <span class="math inline">\(P(D|M)\)</span> is available, we will also compare exact probabilities to those estimated from relative frequency.</p>
<p>We then shift to the probability of multiple events based on the laws of probability for independent events. We show how we can use computation to calculate the relative probability of a specific series of events by comparing it to a multitude of randomly generated series of events. We use the example of finding the probability that a die is weighted (unfair) after an observed series of rolls. This is our more intuitive approach to hypothesis testing.</p>
</section>
<section id="models-of-discrete-data-generating-processes" class="level2">
<h2 class="anchored" data-anchor-id="models-of-discrete-data-generating-processes">Models of Discrete Data Generating Processes</h2>
<section id="a-dice-total-model" class="level3">
<h3 class="anchored" data-anchor-id="a-dice-total-model">A Dice Total Model</h3>
<p>We’d prefer not to spend too much time on toy examples, however, there are a lot of benefits to starting with something that is intuitive and simple. Subsequently we’ll use rolling dice as our first example of a data generating process. It is also convenient that the mathematical model we’ll use is a good approximation of the real data generating process, so long as you’re OK with ignoring all the physical bouncing of the dice and are content with just the result after a roll.</p>
<p>A dice model is built into the app displayed beneath this paragraph. It will simulate rolling the number of dice you specify, as if you threw them out of a cup all at once, and total the value on those dice from the cup, which is considered one roll. Additionally, it will repeat rolling that cup of dice the number of times you specify, and summarize the results on a histogram. Play around with the two inputs/parameters of the dice rolling app below, the number of dice and the number of rolls.</p>
<pre class="shinylive-python" data-engine="python"><code>#| '!! shinylive warning !!': |
#|   shinylive does not work in self-contained HTML documents.
#|   Please set `embed-resources: false` in your metadata.
#| standalone: true
#| viewerHeight: 550

from shiny import App, ui, render, reactive
import numpy as np
import matplotlib.pyplot as plt

app_ui = ui.page_fluid(
    ui.h2("Dice Rolling App"),
    ui.layout_sidebar(
        ui.sidebar(
            ui.input_slider("numDice", "Number of Dice", min=1, max=10, value=2, step=1),
            ui.input_slider("numRolls", "Number of Rolls", min=1, max=10000, value=100, step=1),
        ),
        ui.output_plot("dicePlot", height="400px"),
    ),
)

def server(input, output, session):
    # Define a reactive calculation that depends on numDice and numRolls
    @reactive.Calc
    def dice_sums():
        return [
            np.random.randint(1, 7, input.numDice()).sum()
            for _ in range(input.numRolls())
        ]

    @output
    @render.plot
    def dicePlot():
        current_sums = dice_sums()
        fig, ax1 = plt.subplots()

        # Calculate frequencies and relative frequencies
        unique_sums, counts = np.unique(current_sums, return_counts=True)
        relative_freq = counts / len(current_sums)

        # Create the frequency bars with darker blue
        bars = ax1.bar([str(s) for s in unique_sums], counts, color="steelblue")  
        ax1.set_xlabel("Dice Total")
        ax1.set_ylabel("Frequency", color="steelblue")
        ax1.tick_params(axis='y', labelcolor="steelblue")

        # Create secondary y-axis for relative frequency
        ax2 = ax1.twinx()
        markers = ax2.plot([str(s) for s in unique_sums], relative_freq, 
                          color="r", marker='_', linestyle='None', label="Relative Frequency")
        ax2.set_ylabel("Relative Frequency", color="red")
        ax2.tick_params(axis='y', labelcolor="red")
        
        # Set y-axis limits to start at 0 for relative frequency
        ax2.set_ylim(bottom=0)

        # Set title
        plt.title("Frequency and Relative Frequency of Dice Totals", fontsize=14)
        
        # Add legend
        lines = [bars.patches[0], markers[0]]
        labels = ["Frequency", "Relative Frequency"]
        ax1.legend(lines, labels, loc='upper left')

        # Adjust layout to prevent label cutoff
        plt.tight_layout()
        
        # Rotate x-axis labels after tight_layout
        ax1.tick_params(axis='x', rotation=90)

        return fig

app = App(app_ui, server)</code></pre>
<p>Hopefully you’ve noted how a larger number of rolls seems to give us smoother and more consistent results. We will revisit this point more precisely in a later section.</p>
</section>
<section id="discrete-probability-distributions-as-models-of-data-generating-processes" class="level3">
<h3 class="anchored" data-anchor-id="discrete-probability-distributions-as-models-of-data-generating-processes">Discrete Probability Distributions as Models of Data Generating Processes</h3>
<p>In the last section, we used dice rolling as our data generating process, however there are other discrete processes we may be interested in, such as testing 1,000 products that have a 0.999 probability of success each. As you can imagine, when you change the data generating process, the relative frequency (distribution) of the outcomes change. There are many important discrete processes that can be described with [mostly] analytical mathematical models involving a small set of parameters. These have been given names and we will refer to them as <em>parametric discrete probability distributions</em>. We include <em>parametric</em> to contrast with <em>non-parametric</em> distributions that cannot be described with a small set of parameters, and include <em>discrete</em> to constrast with <em>continuous</em> distributions that can take any real <strong>ℝ</strong> number value.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>If you are familiar with discrete probability distributions, you may have expected them to be introduced as a way to find the exact probability of an event, instead of using them to generate data. We will eventually use this feature, but our goal is to more generally introduce models of data generating processes and their associated probability distributions. Only a small number have properties that allow for nice analytical solutions to the probabilities of their data, and we’d prefer not to constrain ourselves to thinking in only an analytical (as opposed to computational) framework.</p>
</div>
</div>
<p>Initially we want to think about discrete probability distributions in the same way we thought about our dice model, that it is a model that will generate random events from a data generating process of interest. Below are a couple examples to illustrate the point.</p>
<section id="binomial-distribution" class="level4">
<h4 class="anchored" data-anchor-id="binomial-distribution">Binomial Distribution</h4>
<p>The binomial distribution is a model that represents the number of successes in a fixed number of independent trials, where each trial has two possible outcomes (commonly referred to as “success” and “failure”). The probability of success can range between 0 and 1. In the app below you can recreate something like the product testing scenario recently mentioned. Feel free to play around with the settings/parameters to get a feel for how the probability distribution behaves.</p>
<pre class="shinylive-python" data-engine="python"><code>#| '!! shinylive warning !!': |
#|   shinylive does not work in self-contained HTML documents.
#|   Please set `embed-resources: false` in your metadata.
#| standalone: true
#| viewerHeight: 550

from shiny import App, ui, render, reactive
import numpy as np
import matplotlib.pyplot as plt
import math

app_ui = ui.page_fluid(
    ui.h2("Binomial Distribution Simulation with Binned Histogram"),
    ui.layout_sidebar(
        ui.sidebar(
            ui.input_slider(
                "numTrials", 
                "Number of Trials (n)", 
                min=1, 
                max=10000, 
                value=100, 
                step=1
            ),
            ui.input_slider(
                "probSuccess", 
                "Probability of Success (p)", 
                min=0.001, 
                max=0.999, 
                value=0.5, 
                step=0.001
            ),
        ),
        ui.output_plot("binomPlot", height="400px"),
    ),
)

def server(input, output, session):
    FIXED_NUM_SIMULATIONS = 10000

    @reactive.Calc
    def binomial_samples():
        n = input.numTrials()
        p = input.probSuccess()
        size = FIXED_NUM_SIMULATIONS
        return np.random.binomial(n, p, size)
    
    def determine_bin_width(data, max_bins=30):
        data_min = data.min()
        data_max = data.max()
        data_range = data_max - data_min + 1
        for bin_width in range(1, data_range + 1):
            num_bins = math.ceil(data_range / bin_width)
            if num_bins &lt;= max_bins:
                return bin_width
        return 1
    
    @output
    @render.plot
    def binomPlot():
        samples = binomial_samples()
        bin_width = determine_bin_width(samples, max_bins=30)
        
        data_min = samples.min()
        data_max = samples.max()
        bins = np.arange(data_min, data_max + bin_width, bin_width)
        
        counts, bin_edges = np.histogram(samples, bins=bins)
        bin_centers = bin_edges[:-1] + bin_width / 2
        
        # Calculate relative frequencies
        relative_freq = counts / len(samples)
        
        fig, ax1 = plt.subplots(figsize=(10, 6))
        
        # Plot absolute frequencies
        bars = ax1.bar(bin_centers, counts, width=bin_width*0.9, 
                      color="steelblue", alpha=0.6, edgecolor="black", align='center')
        
        ax1.set_xlabel("Number of Successes")
        ax1.set_ylabel("Frequency", color="steelblue")
        ax1.tick_params(axis='y', labelcolor="steelblue")
        
        # Create secondary y-axis for relative frequency
        ax2 = ax1.twinx()
        markers = ax2.plot(bin_centers, relative_freq, 
                          color="red", marker='_', linestyle='None', 
                          markersize=10, markeredgewidth=2, label="Relative Frequency")
        ax2.set_ylabel("Relative Frequency", color="red")
        ax2.tick_params(axis='y', labelcolor="red")
        ax2.set_ylim(bottom=0)
        
        # Set title
        plt.title("Frequency and Relative Frequency of Successes", fontsize=14)
        
        # Add legend
        lines = [bars.patches[0], markers[0]]
        labels = ["Frequency", "Relative Frequency"]
        ax1.legend(lines, labels, loc='upper left')
        
        # Set x-axis ticks
        if len(bin_centers) &gt; 20:
            step = math.ceil(len(bin_centers) / 20)
            ax1.set_xticks(bin_centers[::step])
            ax1.set_xticklabels([int(x) for x in bin_centers[::step]], rotation=90)
        else:
            ax1.set_xticks(bin_centers)
            ax1.set_xticklabels([int(x) for x in bin_centers], rotation=90)
        
        plt.tight_layout()
        
        return fig

app = App(app_ui, server)</code></pre>
</section>
<section id="poisson-distribution" class="level4">
<h4 class="anchored" data-anchor-id="poisson-distribution">Poisson Distribution</h4>
<p>The Poisson distribution is a model that describes the number of events occurring in a fixed interval of time or space, assuming that the events occur independently and at a constant average rate. For example, it might represent the number of phone calls received by a call center in an hour or the number of cars passing through a toll booth in a minute. The Poisson Distribution is similar to the Binomial distribution, except there are not a fixed number of trials, so there is not an upper limit to the number of events returned by a sample. However, values much larger than the average rate become incredibly unlikely.</p>
<pre class="shinylive-python" data-engine="python"><code>#| '!! shinylive warning !!': |
#|   shinylive does not work in self-contained HTML documents.
#|   Please set `embed-resources: false` in your metadata.
#| standalone: true
#| viewerHeight: 550

from shiny import App, ui, render, reactive
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import poisson
import math

app_ui = ui.page_fluid(
    ui.h2("Poisson Distribution Simulation"),
    ui.layout_sidebar(
        ui.sidebar(
            ui.input_slider(
                "rate_param", 
                "Rate Parameter (λ)", 
                min=0.01, 
                max=10.0, 
                value=1.0, 
                step=0.01
            ),
            ui.input_slider(
                "num_trials",
                "Times to Repeat Sample",
                min=100,
                max=10000,
                value=10000,
                step=100
            )
        ),
        ui.output_plot("poissonPlot", height="400px"),
    )
)

def server(input, output, session):
    @reactive.Calc
    def num_simulations():
        return input.num_trials()

    @reactive.Calc
    def poisson_samples():
        lam = input.rate_param()
        n_trials = num_simulations()
        return np.random.poisson(lam, n_trials)
    
    def determine_bin_width(data, max_bins=30):
        data_min = data.min()
        data_max = data.max()
        data_range = data_max - data_min + 1
        for bin_width in range(1, data_range + 1):
            num_bins = math.ceil(data_range / bin_width)
            if num_bins &lt;= max_bins:
                return bin_width
        return 1

    @output
    @render.plot
    def poissonPlot():
        samples = poisson_samples()
        lam = input.rate_param()
        
        bin_width = determine_bin_width(samples, max_bins=30)
        
        data_min = samples.min()
        data_max = samples.max()
        bins = np.arange(data_min, data_max + bin_width, bin_width)
        
        counts, bin_edges = np.histogram(samples, bins=bins)
        bin_centers = bin_edges[:-1] + bin_width / 2
        
        # Calculate relative frequencies
        relative_freq = counts / len(samples)
        
        fig, ax1 = plt.subplots(figsize=(10, 6))
        
        # Plot absolute frequencies
        bars = ax1.bar(bin_centers, counts, width=bin_width*0.9, 
                      color="steelblue", alpha=0.6, edgecolor="black", align='center')
        
        ax1.set_xlabel("Number of Events")
        ax1.set_ylabel("Frequency", color="steelblue")
        ax1.tick_params(axis='y', labelcolor="steelblue")
        
        # Create secondary y-axis for relative frequency
        ax2 = ax1.twinx()
        markers = ax2.plot(bin_centers, relative_freq, 
                          color="red", marker='_', linestyle='None', 
                          markersize=10, markeredgewidth=2, label="Relative Frequency")
        ax2.set_ylabel("Relative Frequency", color="red")
        ax2.tick_params(axis='y', labelcolor="red")
        ax2.set_ylim(bottom=0)
        
        # Set title
        plt.title(f"Frequency and Relative Frequency of Poisson Events", 
                 fontsize=14)
        
        # Add legend
        lines = [bars.patches[0], markers[0]]
        labels = ["Frequency", "Relative Frequency"]
        ax1.legend(lines, labels, loc='upper right')
        
        # Set x-axis ticks
        if len(bin_centers) &gt; 20:
            step = math.ceil(len(bin_centers) / 20)
            ax1.set_xticks(bin_centers[::step])
            ax1.set_xticklabels([int(x) for x in bin_centers[::step]], rotation=90)
        else:
            ax1.set_xticks(bin_centers)
            ax1.set_xticklabels([int(x) for x in bin_centers], rotation=90)
        
        plt.tight_layout()
        
        return fig

app = App(app_ui, server)</code></pre>
</section>
<section id="summary" class="level4">
<h4 class="anchored" data-anchor-id="summary">Summary</h4>
<p>We keep this section brief as there are plenty of easily accessible references for discrete probability distributions. Hopefully the point was made though - that each discrete probability distribution is built on an idealized data generating process, and we can sample from the distribution as a way to model the outcomes of a process.</p>
</section>
</section>
</section>
<section id="probability-of-data" class="level2">
<h2 class="anchored" data-anchor-id="probability-of-data">Probability of Data</h2>
<p>Having given some background on models, we can now focus on the probability of the data given the model, <span class="math inline">\(P(D|M)\)</span>.</p>
<section id="dice-totals-probability-of-data" class="level3">
<h3 class="anchored" data-anchor-id="dice-totals-probability-of-data">Dice Totals Probability of Data</h3>
<section id="relative-frequency" class="level4">
<h4 class="anchored" data-anchor-id="relative-frequency">Relative Frequency</h4>
<p>We want to find the probability of a particular dice total (the data) given a dice model. To estimate the probability <span class="math inline">\(P(E)\)</span> of an event <span class="math inline">\(E\)</span>, we can use the relative frequency approach. This involves counting the number of occurrences of the event E and dividing it by the total number of trials. For example, if we observed a total of twelve occur in 40 out of 5,000 dice rolls, the probability estimate is:</p>
<p><span class="math display">\[
P(E) \approx \frac{\text{Number of times event } E \text{ occurs}}{\text{Total number of trials}} = \frac{40}{5000} = 0.008
\]</span></p>
</section>
<section id="law-of-large-numbers" class="level4">
<h4 class="anchored" data-anchor-id="law-of-large-numbers">Law of Large Numbers</h4>
<p>The accuracy of this estimate depends on the total number of trials as governed by the Law of Large Numbers. The standard error, which gives a measure of uncertainty in the estimate of a mean value, is proportional to one over the square root of the number of samples:</p>
<p><span class="math display">\[
P_{\text{error}} \propto \frac{1}{\sqrt{N_{\text{total}}}}
\]</span></p>
<p>Which indicates there are diminishing returns to just making the sample size larger. Now I know you’re smart, and you’re saying to yourself, I can figure out the <em>exact</em> probability of rolling a certain dice total. Of course you can for this example - but you probably can’t for more realistic examples, and we want to learn techniques that work well for real problems. In general, if you are concerned with the quality of an estimate with this approach, just rerun the model and see if the outcome changes meaningfully - if it does, increase the number of times we run the model until the output is stable enough for your application. If that’s still not enough, dig into exact/analytic methods.</p>
</section>
<section id="revised-dice-app" class="level4">
<h4 class="anchored" data-anchor-id="revised-dice-app">Revised Dice App</h4>
<p>Here’s another version of the Dice Total App that you saw earlier - except it now has additional functionality to calculate the approximate and exact probability of a certain dice total based on your inputs. It also shows the relative frequency of the dice sums, i.e.&nbsp;a true probability distribution where the sum of the probabilities equals one.</p>
<pre class="shinylive-python" data-engine="python"><code>#| '!! shinylive warning !!': |
#|   shinylive does not work in self-contained HTML documents.
#|   Please set `embed-resources: false` in your metadata.
#| standalone: true
#| viewerHeight: 560

from shiny import App, ui, render, reactive
import numpy as np
import matplotlib.pyplot as plt

# --- Utility function to compute exact distribution of sums for n dice ---
def dice_sum_distribution(n_dice):
    """
    Return a list 'dist' where dist[s] = probability of sum s for n_dice dice.
    Indices go from 0 up to 6*n_dice. Only sums in range [n_dice..6*n_dice]
    have nonzero probabilities.
    """
    # ways[s] = number of ways to get sum s
    ways = [0] * (6*n_dice + 1)
    ways[0] = 1  # base case

    for _ in range(n_dice):
        new_ways = [0] * (6*n_dice + 1)
        for sum_val, count in enumerate(ways):
            if count &gt; 0:
                for face in range(1, 7):
                    new_ways[sum_val + face] += count
        ways = new_ways

    total_outcomes = 6 ** n_dice
    dist = [count / total_outcomes for count in ways]
    return dist

# -------------------------- UI Definition ---------------------------
app_ui = ui.page_fluid(
    ui.h2("Dice Rolling App with Probability Mass Function"),
    ui.layout_sidebar(
        ui.sidebar(
            ui.input_slider("numDice", "Number of Dice", min=1, max=10, value=2, step=1),
            ui.input_slider("numRolls", "Number of Rolls", min=1, max=10000, value=100, step=1),
            ui.input_select(
                "selectedTotal", 
                "Select Dice Total", 
                choices=[""],   # initially empty, will be updated dynamically
                multiple=False,
            ),
            ui.output_text("approxProbability"),
            ui.output_text("exactProbability")
        ),
        ui.output_plot("dicePlot", height="400px"),
    )
)

# -------------------------- Server Definition -------------------------
def server(input, output, session):
    # Reactive: Generate random sums based on numDice and numRolls
    @reactive.Calc
    def dice_sums():
        return [
            np.random.randint(1, 7, input.numDice()).sum()
            for _ in range(input.numRolls())
        ]

    # Reactive: Exact distribution of sums for the current number of dice
    @reactive.Calc
    def exact_distribution():
        return dice_sum_distribution(input.numDice())

    # Dynamically update the choices in the 'selectedTotal' select input
    @reactive.Effect
    def _():
        current_sums = dice_sums()
        unique_sums = sorted(np.unique(current_sums))
        ui.update_select(
            "selectedTotal",
            choices=[str(s) for s in unique_sums],
            selected=str(unique_sums[0]) if len(unique_sums) &gt; 0 else ""
        )

    # Plot the relative frequency of dice totals
    @output
    @render.plot
    def dicePlot():
        current_sums = dice_sums()
        
        fig, ax = plt.subplots()
        
        # Get theoretical distribution first to set x-axis limits
        dist = exact_distribution()
        theoretical_sums = range(input.numDice(), 6*input.numDice()+1)
        theoretical_probs = [dist[i] for i in theoretical_sums]
        
        # Create dictionary to store empirical probabilities for all possible sums
        empirical_dict = {i: 0 for i in theoretical_sums}
        unique_sums, counts = np.unique(current_sums, return_counts=True)
        for sum_val, count in zip(unique_sums, counts):
            if sum_val in empirical_dict:
                empirical_dict[sum_val] = count / len(current_sums)
        
        # Plot empirical distribution
        ax.bar([str(s) for s in theoretical_sums], 
               [empirical_dict[s] for s in theoretical_sums],
               color="steelblue", label="Empirical")
        
        # Plot theoretical distribution
        ax.plot([str(s) for s in theoretical_sums], theoretical_probs, 
                'r', marker='_', linestyle='', label="Theoretical")

        ax.set_title("Probability Mass Function of Dice Totals")
        ax.set_xlabel("Dice Total")
        ax.set_ylabel("Probability")
        ax.legend()
        plt.xticks(rotation=90)

        return fig

    # Approximate probability of the selected dice total
    @output
    @render.text
    def approxProbability():
        if not input.selectedTotal():
            return "Select a dice total to see probabilities."

        current_sums = dice_sums()
        selected_total = int(input.selectedTotal())

        count = sum(1 for x in current_sums if x == selected_total)
        if len(current_sums) == 0:
            prob = 0
        else:
            prob = count / len(current_sums)

        return f"Approx. Probability of {selected_total}: {prob:.4f}"

    # Exact probability of the selected dice total
    @output
    @render.text
    def exactProbability():
        if not input.selectedTotal():
            return ""

        selected_total = int(input.selectedTotal())
        dist = exact_distribution()

        # If the selected total is out of range, probability is 0
        if selected_total &lt; 0 or selected_total &gt;= len(dist):
            prob = 0
        else:
            prob = dist[selected_total]

        return f"Exact Probability of {selected_total}: {prob:.4f}"

app = App(app_ui, server)</code></pre>
<p>Hopefully you can demonstrate to yourself that with enough samples, the approximate probability calculation is awfully close to the exact probability. However, there is an exception. The tails (the slim far ends) are not as accurate. Properly calculating probability in these tail sections happens to be trivial for dice where an exact solution is available, but for a real problem, accurate tail probabilities are incredibly difficult.</p>
</section>
</section>
<section id="exact-probabilities-from-a-discrete-probability-distribution" class="level3">
<h3 class="anchored" data-anchor-id="exact-probabilities-from-a-discrete-probability-distribution">Exact Probabilities from a Discrete Probability Distribution</h3>
<p>Here we provide an example of the more ‘typical’ use of a parametric discrete probability distribution, to compute the probability of an event. Let’s use the properties of the binomial probability distribution to determine the probability of having less than 999 products pass a quality test when we have a true 0.999 pass rate and we inspect 1,000 products.</p>
<p>We’ll solve this problem by computing the probability of having 999 or 1,000 products pass, and then just inverting the probability. Note that <span class="math inline">\(P(X = 1000)\)</span> is simplified below based on the <em>multiplication rule of independent events</em> to equal 0.999^1,000. Also, if you’re unfamiliar with the n over k in parenthesis, look up ‘n choose k’.</p>
<p><span class="math display">\[
P(X = k) = \binom{n}{k} p^k (1-p)^{n-k}
\]</span></p>
<p><span class="math display">\[
P(X = 999) + P(X = 1,000) = \binom{1000}{999} (0.999)^{999} (0.001)^1 + (0.999)^{1,000}
\]</span></p>
<p>The result is 0.736, so the chance of having a real pass rate of 0.999 and having less than 999 pass is 1 - 0.736 = 0.264. It’s fairly plausible to have 0.999 pass rate and have a couple of products fail. However, if you had four or more fail, you should have a very hard time convincing management that it was just ‘bad luck’. The more formal way to discuss this is <em>hypothesis testing</em>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Much of statistics is dedicated to hypothesis testing. There’s no reason for this primer to repeat such a repeated topic. The problem though, is that in the real world, folks get it wrong. I have a simple hypothesis for this, and that’s because non-expert practitioners do not understand their statistical models. And there’s good reasons they don’t, they are often analytical mathematical ‘magic’ with buried assumptions. We take a different approach.</p>
</div>
</div>
</section>
<section id="probability-of-multiple-events" class="level3">
<h3 class="anchored" data-anchor-id="probability-of-multiple-events">Probability of Multiple Events</h3>
<p>So far we have only considered <span class="math inline">\(P(D|M)\)</span> where the data is a single event. However, it is more common to have multiple events (i.e.&nbsp;multiple data points), and we’d like to know the probability of a specific dataset vs other datasets we may have sampled. To calculate probabilities we’ll use the <em>multiplication rule of independent events</em>. In practice it may be very difficult to prove perfectly independent events - however be sure there is not a reason for strong correlation, such as almost all <em>time series</em>.</p>
<p>To calculate the probability of <span class="math inline">\(n\)</span> independent events <span class="math inline">\(E_1, E_2, \ldots, E_n\)</span>, we simply multiply them together:</p>
<p><span class="math display">\[
P\left( \bigcap_{i=1}^{n} E_i \right) = \prod_{i=1}^{n} P(E_i)
\]</span></p>
<p>Where the left side of the equation refers to the probability of multiple independent events, and the right side describes multiplying the probability of each event in a continuous chain.</p>
<section id="numerical-stability" class="level4">
<h4 class="anchored" data-anchor-id="numerical-stability">Numerical Stability</h4>
<p>We should also mention for many small probabilities, multiplication risks numerical instability. However there is one very simple and clever workaround to this, which is to add log probabilities instead:</p>
<p><span class="math display">\[
P(A \cap B \cap C \cap \dots) = P(A) \cdot P(B) \cdot P(C) \cdot \dots = 10^{(\log_{10}(P(A)) + \log_{10}(P(B)) + \log_{10}(P(C)) + \dots))}
\]</span></p>
</section>
<section id="example" class="level4">
<h4 class="anchored" data-anchor-id="example">Example</h4>
<p>Let’s work through a couple example calculations before extending it to a scenario that approximates more serious problems we’ll tackle later. What is the probability of rolling three dice out of a cup, where the total is 11, and then rolling the dice again, where the total is 7? We use the app above to get the probabilities of each roll, where 11 = 0.1250 and 7 = 0.0694.</p>
<p><span class="math display">\[
P(Roll 1 \cap Roll 2) = 0.1250 \cdot 0.0694 = 0.008675 = 10^{(\log_{10}(0.1250) + \log_{10}(0.0694))}
\]</span></p>
<p>If we stay in log probabilities, as that is generally more convenient:</p>
<p><span class="math display">\[
\log_{10}(P(Roll 1 \cap Roll 2)) = \log_{10}(0.1250) + \log_{10}(0.0694) = -0.9031 + -1.1586 = -2.0617
\]</span></p>
</section>
</section>
<section id="calculating-the-relative-probability-of-multiple-events" class="level3">
<h3 class="anchored" data-anchor-id="calculating-the-relative-probability-of-multiple-events">Calculating the Relative Probability of Multiple Events</h3>
<p>With the background from the last section we can now simulate the probability of multiple events. However, often it is more useful to think about the relative probability of a long series of events rather than the absolute probability, since the absolute probability will be tiny. I think an example will help. Again, to have better intuition about the problem, we’ll use dice, although it can obviously be extended to other discrete probability distributions.</p>
<p>We’ll extend the recent example of rolling three dice out of a cup. We’ll let most of our simulations use fair dice, and we’ll show the log probability of each exact series of events as we perform rolls out of the cup. Note that for three dice, the values can range from 3 to 18, and values near the middle, such as 10, will be more common than those at the end, such as 3 or 18. The log probability of more rare events will be more negative. If we have a series of very unlikely events, the values will become negative more quickly.</p>
<p>We’re also going to include one series of rolls with a cup of three weighted dice, which will be the dotted blue line. The values and probabilities will be 1=0.10, 2=0.10, 3=0.15, 4=0.15, 5=0.2, 6=0.3. If we expect the outcomes of fair dice, we’ll see that the weighted dice will usually trend towards being a fairly improbable series of rolls. We can refer to the percentile of their log-probability to see how unusual they are.</p>
<pre class="shinylive-python" data-engine="python"><code>#| '!! shinylive warning !!': |
#|   shinylive does not work in self-contained HTML documents.
#|   Please set `embed-resources: false` in your metadata.
#| standalone: true
#| viewerHeight: 650

from shiny import App, ui, render, reactive
import numpy as np
import matplotlib.pyplot as plt

# --- Utility Functions ---

def roll_three_dice_fair():
    """Simulate rolling three fair dice and return their sum."""
    return np.sum(np.random.randint(1, 7, size=3))

def roll_three_dice_weighted():
    """Simulate rolling three weighted dice and return their sum."""
    weights = [0.10, 0.10, 0.15, 0.15, 0.2, 0.30]
    # Define possible outcomes
    outcomes = [1, 2, 3, 4, 5, 6]
    # Roll three weighted dice
    return np.sum(np.random.choice(outcomes, size=3, p=weights))

def get_probability_of_sum(dice_sum):
    """Calculate probability of getting a specific sum with three fair dice."""
    possibilities = 0
    total_outcomes = 216  # 6^3 possible outcomes
    
    for i in range(1, 7):
        for j in range(1, 7):
            for k in range(1, 7):
                if i + j + k == dice_sum:
                    possibilities += 1
                        
    return possibilities / total_outcomes

def get_probability_of_sum_weighted(dice_sum):
    # We want to pretend it has the same probability and see how much of an outlier weighted dice are
    return get_probability_of_sum(dice_sum)

def simulate_rolls_fair(num_rolls=10):
    """Simulate a series of rolls with fair dice and calculate cumulative log probability."""
    rolls = [roll_three_dice_fair() for _ in range(num_rolls)]
    probabilities = [get_probability_of_sum(roll) for roll in rolls]
    
    # To handle log(0), replace zero probabilities with a very small number
    probabilities = [p if p &gt; 0 else 1e-10 for p in probabilities]
    log_probs = np.log10(probabilities)
    cumulative_log_probs = np.cumsum(log_probs)
    
    return rolls, cumulative_log_probs

def simulate_rolls_weighted(num_rolls=10):
    """Simulate a series of rolls with weighted dice and calculate cumulative log probability."""
    rolls = [roll_three_dice_weighted() for _ in range(num_rolls)]
    probabilities = [get_probability_of_sum_weighted(roll) for roll in rolls]
    
    # To handle log(0), replace zero probabilities with a very small number
    probabilities = [p if p &gt; 0 else 1e-10 for p in probabilities]
    log_probs = np.log10(probabilities)
    cumulative_log_probs = np.cumsum(log_probs)
    
    return rolls, cumulative_log_probs

# -------------------------- UI Definition ---------------------------
app_ui = ui.page_fluid(
    ui.h2("Three-Dice Roll Simulations with Cumulative Log Probability"),
    ui.layout_sidebar(
        ui.sidebar(
            ui.input_select(
                "selectedSim", 
                "Select Simulation to Highlight", 
                choices=[],   # initially empty, will be updated dynamically
                multiple=False,
            ),
            ui.output_text("selectedDetails"),
            ui.hr(),
            # Removed the Number of Simulations slider
            # Set Number of Simulations to 100 for fair and 5 for weighted
            # Retain Number of Rolls slider
            ui.input_slider("numRolls", "Number of Rolls per Simulation", min=5, max=100, value=10, step=1),
            ui.input_action_button("runSim", "Run Simulations")
        ),
        ui.output_plot("probPlot", height="500px"),
    )
)

# -------------------------- Server Definition -------------------------
def server(input, output, session):
    # Reactive value to store simulations as a list of tuples: (label, cum_log_probs)
    simulations = reactive.Value([])
    
    # Reactive: Perform simulations when 'Run Simulations' button is clicked
    @reactive.Effect
    def _run_simulations():
        input.runSim()  # Depend on the runSim button
        num_rolls = input.numRolls()
        new_simulations = []
        
        # Run 99 fair simulations (99 + 1 unfair = 100)
        num_sim_fair = 99
        for i in range(num_sim_fair):
            _, cum_probs = simulate_rolls_fair(num_rolls)
            label = f"Simulation {i+1}"
            new_simulations.append((label, cum_probs))
        
        # Run 1 weighted simulations (was 5)
        num_sim_weighted = 1
        for i in range(num_sim_weighted):
            _, cum_probs = simulate_rolls_weighted(num_rolls)
            label = f"Weighted Simulation {i+1}"
            new_simulations.append((label, cum_probs))
        
        simulations.set(new_simulations)
        
        # Update the select input choices
        sim_choices = [sim[0] for sim in new_simulations]
        ui.update_select(
            "selectedSim",
            choices=sim_choices,
            selected=sim_choices[0] if sim_choices else ""
        )
    
    # Initialize simulations on app start
    @reactive.Effect
    def _initialize():
        input.runSim()  # Trigger initial simulation run
    
    # Plot the simulations, highlighting the selected one
    @output
    @render.plot
    def probPlot():
        sims = simulations()
        num_sim = len(sims)
        if num_sim == 0:
            fig, ax = plt.subplots()
            ax.text(0.5, 0.5, "No simulations to display.\nClick 'Run Simulations' to start.", 
                    horizontalalignment='center', verticalalignment='center', fontsize=12)
            ax.axis('off')
            return fig
        
        num_rolls = len(sims[0][1])
        x = np.arange(1, num_rolls + 1)
        
        fig, ax = plt.subplots(figsize=(10, 6))
        
        # Plot all fair simulations in light gray
        for label, probs in sims:
            if label.startswith("Simulation "):
                ax.plot(x, probs, color='#D3D3D3', alpha=0.5)
        
        # Plot all weighted simulations in blue
        for label, probs in sims:
            if label.startswith("Weighted Simulation "):
                ax.plot(x, probs, color='blue', alpha=0.7, linestyle='--')
        
        # Highlight the selected simulation
        selected = input.selectedSim()
        if selected:
            try:
                # Find the simulation by label
                selected_sim = next((sim for sim in sims if sim[0] == selected), None)
                if selected_sim:
                    label, selected_probs = selected_sim
                    color = 'red' if label.startswith("Simulation ") else 'green'
                    linestyle = '-' if label.startswith("Simulation ") else '--'
                    ax.plot(x, selected_probs, color=color, linewidth=2.5, linestyle=linestyle, label=label)
            except (IndexError, ValueError):
                pass
        
        ax.set_xlabel('Number of Rolls')
        ax.set_ylabel('Cumulative Log10 Probability')
        ax.set_title('Cumulative Log Probability of Multiple Three-Dice Roll Simulations')
        ax.grid(True)
        if selected:
            ax.legend()
        
        plt.tight_layout()
        return fig
    
    # Display details of the selected simulation, including percentile
    @output
    @render.text
    def selectedDetails():
        sims = simulations()
        selected = input.selectedSim()
        if not selected:
            return "No simulation selected."
        try:
            # Find the simulation by label
            selected_sim = next((sim for sim in sims if sim[0] == selected), None)
            if not selected_sim:
                return "Selected simulation not found."
            label, cum_probs = selected_sim
            # Get the final cumulative log probability
            final_log_prob = cum_probs[-1]
            # Collect all final cumulative log probabilities
            all_final_log_probs = [sim[1][-1] for sim in sims]
            # Compute percentile
            percentile = (np.sum(np.array(all_final_log_probs) &lt;= final_log_prob) / len(all_final_log_probs)) * 100
            return (
                f"{label}\n\n"
                f"Final Cumulative Log10 Probability: {final_log_prob:.4f}\n"
                f"Percentile: {percentile:.2f}th"
            )
        except (IndexError, ValueError):
            return "Invalid selection."

app = App(app_ui, server)</code></pre>
<p>You may notice that it’s easier to spot the weighted dice with a longer series of rolls. In just a couple of rolls they often don’t seem that unusual, but most of the time over 100 roles they have a markedly different slope than the other roles. When we calculate the percentile of the weighted dice, we are approximating the p-value of a hypothesis test. The p-value essentially says, if you assume your model is correct, here is the probability of witnessing data as, or more, extreme than what you witnessed. If the p-value becomes small enough, you may suspect it’s not bad luck, but that the data is being generated by a different model.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Traditional hypothesis testing starts with a <em>null</em> model which we can think of as the status quo. If the data has less than a (traditionally) 0.05 probability of being generated by that <em>null</em> model, we assume that something other than the <em>null</em> model generated the data.</p>
</div>
</div>
</section>
</section>
<section id="appendix-on-probability-distributions" class="level2">
<h2 class="anchored" data-anchor-id="appendix-on-probability-distributions">Appendix on Probability Distributions</h2>
<p>For the interested reader, we include an appendix to try to cement more general concepts of probability distributions.</p>
<p>John K. Kruschke said it well:</p>
<blockquote class="blockquote">
<p>A probability distribution is simply a list of all possible outcomes and their corresponding probabilities.</p>
</blockquote>
<p>We think probability distributions in statistics is confusing because of the extreme emphasis on the named parametric probability distributions. Here we build up intuition for probability distributions in the general sense, with some reference to the named parametric probability distributions when appropriate.</p>
<section id="joint-discrete-probability-distributions" class="level3">
<h3 class="anchored" data-anchor-id="joint-discrete-probability-distributions">Joint Discrete Probability Distributions</h3>
<p>The first thing we normally note in a data generating process is what we consider to be the outcome, or in common mathematical parlance, the <span class="math inline">\(y\)</span> variable. For example, if we are asking whether a car breaks down over the course of a year, we want P(Breakdown).</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Breakdown</th>
<th>Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Yes</td>
<td>0.30</td>
</tr>
<tr class="even">
<td>No</td>
<td>0.70</td>
</tr>
</tbody>
</table>
<p>This is an <em>empirical</em> discrete probability distribution as it is based on observations (or in this case made up observations). We could also track whether a car, over the course of a year, has experienced extreme heat, which we could call P(Extreme_Heat).</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Extreme_Heat</th>
<th>Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Yes</td>
<td>0.40</td>
</tr>
<tr class="even">
<td>No</td>
<td>0.60</td>
</tr>
</tbody>
</table>
<p>Now, we could be interested in the combination of the two things, which would be the combination of all possible P(Breakdown) and P(Extreme_Heat) outcomes, which we’d call P(Breakdown, Extreme_Heat). Here’s a possible version of that joint probability distribution:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Breakdown</th>
<th>Extreme_Heat</th>
<th>Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Yes</td>
<td>Yes</td>
<td>0.10</td>
</tr>
<tr class="even">
<td>Yes</td>
<td>No</td>
<td>0.20</td>
</tr>
<tr class="odd">
<td>No</td>
<td>Yes</td>
<td>0.30</td>
</tr>
<tr class="even">
<td>No</td>
<td>No</td>
<td>0.40</td>
</tr>
</tbody>
</table>
<p>Now it’s worth pointing out that while many of us may be interested in the breakdown outcome, one could also be interested in the extreme heat outcome - what we consider the <span class="math inline">\(y\)</span> can be a matter of perspective. Now it’s obvious that more variables could be part of this joint probability distribution, although their usefulness ultimately depends on how correlated they are to the outcome of interest. Lets assume we want to predict breakdowns, so we add another variable that is probably useful. Now we have P(Brand, Breakdown, Extreme_Heat) in a joint probability distribution:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Brand</th>
<th>Breakdown</th>
<th>Extreme Heat</th>
<th>Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BrandA</td>
<td>Yes</td>
<td>Yes</td>
<td>0.05</td>
</tr>
<tr class="even">
<td>BrandA</td>
<td>Yes</td>
<td>No</td>
<td>0.10</td>
</tr>
<tr class="odd">
<td>BrandA</td>
<td>No</td>
<td>Yes</td>
<td>0.15</td>
</tr>
<tr class="even">
<td>BrandA</td>
<td>No</td>
<td>No</td>
<td>0.20</td>
</tr>
<tr class="odd">
<td>BrandB</td>
<td>Yes</td>
<td>Yes</td>
<td>0.10</td>
</tr>
<tr class="even">
<td>BrandB</td>
<td>Yes</td>
<td>No</td>
<td>0.10</td>
</tr>
<tr class="odd">
<td>BrandB</td>
<td>No</td>
<td>Yes</td>
<td>0.10</td>
</tr>
<tr class="even">
<td>BrandB</td>
<td>No</td>
<td>No</td>
<td>0.20</td>
</tr>
</tbody>
</table>
<p>We could imagine all sorts of variables that may impact Breakdown. Please also note, that regardless of how many variables we have, the probability column always sums to 1. Also note that we chose only two possibilities for each column (e.g.&nbsp;BrandA, BrandB), but there could have been many more.</p>
</section>
<section id="conditional-discrete-probability-distributions" class="level3">
<h3 class="anchored" data-anchor-id="conditional-discrete-probability-distributions">Conditional Discrete Probability Distributions</h3>
<p>A conditional probability distribution is one in which we are given the state of one or more variables. For example, let’s examine P(Breakdown, Extreme_Heat | Brand = BrandB), which in words is the joint probability distribution of Breakdown and Extreme_Heat given that Brand = BrandB.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Brand</th>
<th>Breakdown</th>
<th>Extreme Heat</th>
<th>Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>BrandB</td>
<td>Yes</td>
<td>Yes</td>
<td>0.20</td>
</tr>
<tr class="even">
<td>BrandB</td>
<td>Yes</td>
<td>No</td>
<td>0.20</td>
</tr>
<tr class="odd">
<td>BrandB</td>
<td>No</td>
<td>Yes</td>
<td>0.20</td>
</tr>
<tr class="even">
<td>BrandB</td>
<td>No</td>
<td>No</td>
<td>0.40</td>
</tr>
</tbody>
</table>
<p>Because BrandB is a constant, we could just write it this way:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Breakdown</th>
<th>Extreme Heat</th>
<th>Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Yes</td>
<td>Yes</td>
<td>0.20</td>
</tr>
<tr class="even">
<td>Yes</td>
<td>No</td>
<td>0.20</td>
</tr>
<tr class="odd">
<td>No</td>
<td>Yes</td>
<td>0.20</td>
</tr>
<tr class="even">
<td>No</td>
<td>No</td>
<td>0.40</td>
</tr>
</tbody>
</table>
<p>Note how this is not the same probability distribution as P(Breakdown, Extreme_Heat).</p>
<p>When we work with a parametric probability distribution, like the binomial, we give the value of the distributions parameters so they can be plugged into the mathematical model of the data generating process - which is what distinguishes it from an empirical distribution. Here is a discrete probability distribution for a Binomial process with n=3 and p=0.2, i.e.&nbsp;P( k | n=3, p=0.2).</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Successes (k)</th>
<th>n</th>
<th>k</th>
<th>Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>3</td>
<td>0.2</td>
<td>0.512</td>
</tr>
<tr class="even">
<td>1</td>
<td>3</td>
<td>0.2</td>
<td>0.384</td>
</tr>
<tr class="odd">
<td>2</td>
<td>3</td>
<td>0.2</td>
<td>0.096</td>
</tr>
<tr class="even">
<td>3</td>
<td>3</td>
<td>0.2</td>
<td>0.008</td>
</tr>
</tbody>
</table>
<p>Because n and k are constant, we may prefer a table without them, although they are still there, implicitly.</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Successes (k)</th>
<th>Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>0</td>
<td>0.512</td>
</tr>
<tr class="even">
<td>1</td>
<td>0.384</td>
</tr>
<tr class="odd">
<td>2</td>
<td>0.096</td>
</tr>
<tr class="even">
<td>3</td>
<td>0.008</td>
</tr>
</tbody>
</table>
<p>We can’t examine the joint probability distribution of the Binomial distribution without giving a value for n and p because the number of possibilities for n and p are infinite, and subsequently the joint probability distribution is infinite. Note we can effectively do the same thing with the ‘Breakdown’ joint probability distribution if we just changed extreme_heat to temperature, and tried to observe breakdowns for every temperature. The <em>named</em> probability distributions are special in that we have a complete mathematical description of the process, so we can simply calculate the results of any combination, while in the empirical distribution of Breakdown, we would have to observe the results.</p>
<p>It is also possible to have a probability distribution from one of the parametric probability distributions in which we have a set of values for the parameters, instead of one value. For example, we can have a Binomial distribution using the set notation <span class="math inline">\(\in\)</span> which states that <span class="math inline">\(n\)</span> must be either 3 or 4 and <span class="math inline">\(p\)</span> must be either 0.2 or 0.3.</p>
<p><span class="math display">\[
P(k, \quad n \in \{3, 4\}, \quad p \in \{0.2, 0.3\})
\]</span></p>
<p>We should also explicity define how each combination in the set contributes to the total probability, but for this simple example we will assume they contribute equally. This is like the ‘Breakdown’ table which was limited to the following set of data:</p>
<p><span class="math display">\[
P(Breakdown, \quad ExtremeHeat \in \{Yes, No\}, \quad Brand \in \{BrandA, BrandB\})
\]</span></p>
<p>At this point hopefully the empirical and parametric probability distributions ‘feel’ the same, except we know the mathematical models behind the parametric probability distributions, so we do not have to guess their distributions through observation.</p>
</section>
<section id="marginal-discrete-probability-distributions" class="level3">
<h3 class="anchored" data-anchor-id="marginal-discrete-probability-distributions">Marginal Discrete Probability Distributions</h3>
<p>A marginal probability distribution is essentially a way to work from the end of the section <em>Joint Discrete Probability Distributions</em> backwards to the beginning - which is a way to eliminate variables from the joint probability distribution and make them simpler. Let’s say we want to eliminate the Extreme_Heat variable:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Breakdown</th>
<th>Extreme_Heat</th>
<th>Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Yes</td>
<td>Yes</td>
<td>0.10</td>
</tr>
<tr class="even">
<td>Yes</td>
<td>No</td>
<td>0.20</td>
</tr>
<tr class="odd">
<td>No</td>
<td>Yes</td>
<td>0.30</td>
</tr>
<tr class="even">
<td>No</td>
<td>No</td>
<td>0.40</td>
</tr>
</tbody>
</table>
<p>We simply add up all the possible values of Extreme_Heat within a given Breakdown, e.g.&nbsp;for Breakdown = Yes, 0.10 + 0.20, and for Breakdown = No, 0.30+ 0.40. Then we arrive at the original table:</p>
<table class="caption-top table">
<thead>
<tr class="header">
<th>Breakdown</th>
<th>Probability</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Yes</td>
<td>0.30</td>
</tr>
<tr class="even">
<td>No</td>
<td>0.70</td>
</tr>
</tbody>
</table>
<p>The name ‘marginal’ comes from the fact that, in the times of paper tables, a statistician could do this addition and write the result in the margin.</p>
</section>
<section id="summary-app" class="level3">
<h3 class="anchored" data-anchor-id="summary-app">Summary App</h3>
<p>After the discussion on probability distributions, we think, as usual, that it is best to learn by applying the concepts in a very hands-on way. Use the app below to see the behavior of a dataset under different joint and marginal conditions.</p>
<pre class="shinylive-python" data-engine="python"><code>#| '!! shinylive warning !!': |
#|   shinylive does not work in self-contained HTML documents.
#|   Please set `embed-resources: false` in your metadata.
#| standalone: true
#| viewerHeight: 600

from shiny import App, ui, render, reactive
import numpy as np
import pandas as pd

app_ui = ui.page_fluid(
    ui.h2("Simulated Breakdown Data"),
    ui.layout_sidebar(
        ui.sidebar(
            ui.input_slider(
                "numEvents",
                "Number of Simulated Outcomes",
                min=1,
                max=100000,
                value=10000,
                step=1000,
            ),
            ui.input_checkbox_group(
                "covariates",
                "Select Covariates to Group By",
                choices=["Mileage", "Brand"],
                inline=True,
                selected=["Mileage", "Brand"],
            ),
            ui.input_select(
                "filter_covariate",
                "Conditional Filter: Choose Covariate",
                choices=["None", "Mileage", "Brand"],
                selected="None",
            ),
            # Dynamic UI element for filter value input:
            ui.output_ui("filter_value_ui"),
        ),
        ui.output_table("results_table")
    ),
)

def server(input, output, session):
    # Set the seed for reproducibility.
    np.random.seed(42)
    
    @reactive.Calc
    def simulated_data():
        n = input.numEvents()
        miles_driven = np.random.lognormal(mean=np.log(10000), sigma=0.5, size=n)
        brands = np.random.choice(
            ["Brand_A", "Brand_B", "Brand_C"],
            size=n,
            p=[0.4, 0.4, 0.2],
        )
        beta_miles = 0.0000000001
        brand_effects = {"Brand_A": 0.001, "Brand_B": 0.0005, "Brand_C": -0.0002}
        lambda_vals = np.exp(beta_miles * miles_driven + np.vectorize(brand_effects.get)(brands))
        breakdowns = np.random.poisson(lambda_vals)
        data = pd.DataFrame({
            "Miles_Driven": miles_driven,
            "Brand": brands,
            "Breakdowns": breakdowns,
        })
        data["Miles_Binned"] = (data["Miles_Driven"] // 10000) * 10000
        return data

    @reactive.Calc
    def grouped_table():
        data = simulated_data()
        covariates = input.covariates()
        group_cols = []
        if "Mileage" in covariates:
            group_cols.append("Miles_Binned")
        if "Brand" in covariates:
            group_cols.append("Brand")
        group_cols.append("Breakdowns")
        
        grouped = data.groupby(group_cols).size().reset_index(name="Frequency")
        
        filter_cov = input.filter_covariate()
        if filter_cov != "None":
            if filter_cov == "Mileage":
                filter_val = input.filter_value()
                if filter_val is not None:
                    grouped = grouped[grouped["Miles_Binned"] == float(filter_val)]
            elif filter_cov == "Brand":
                filter_val = input.filter_value()
                if filter_val is not None:
                    grouped = grouped[grouped["Brand"] == filter_val]
        
        total_freq = grouped["Frequency"].sum()
        if total_freq &gt; 0:
            grouped["Probability"] = grouped["Frequency"] / total_freq
        else:
            grouped["Probability"] = 0
        return grouped

    @output
    @render.table
    def results_table():
        return grouped_table()

    @output
    @render.ui
    def filter_value_ui():
        filter_cov = input.filter_covariate()
        if filter_cov == "Mileage":
            data = simulated_data()
            unique_bins = sorted(data["Miles_Binned"].unique())
            return ui.input_select(
                "filter_value",
                "Select Mileage Bin",
                choices=[str(int(x)) for x in unique_bins],
            )
        elif filter_cov == "Brand":
            return ui.input_select(
                "filter_value",
                "Select Brand",
                choices=["Brand_A", "Brand_B", "Brand_C"],
            )
        else:
            return ui.div()

app = App(app_ui, server)
</code></pre>
<!-- ```{shinylive-python}
from shiny import App, ui, render, reactive
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

app_ui = ui.page_fluid(
    ui.navset_tab(
        ui.nav("Table",
            ui.layout_sidebar(
                ui.sidebar(
                    ui.input_slider(
                        "numEvents",
                        "Number of Simulated Outcomes",
                        min=1,
                        max=100000,
                        value=10000,
                        step=1000,
                    ),
                    ui.input_checkbox_group(
                        "covariates",
                        "Select Covariates to Group By",
                        choices=["Mileage", "Brand"],
                        inline=True,
                        selected=["Mileage", "Brand"],
                    ),
                    ui.input_select(
                        "filter_covariate",
                        "Conditional Filter: Choose Covariate",
                        choices=["None", "Mileage", "Brand"],
                        selected="None",
                    ),
                    ui.output_ui("filter_value_ui"),
                ),
                ui.output_table("results_table")
            )
        ),
        ui.nav("Histogram",
            ui.layout_sidebar(
                ui.sidebar(
                    ui.input_select(
                        "hist_var",
                        "Select Variable for Histogram",
                        choices=["Miles_Driven", "Miles_Binned", "Breakdowns", "Brand"],
                        selected="Miles_Driven"
                    )
                ),
                ui.output_plot("hist_plot")
            )
        ),
        ui.nav("XY Plot",
            ui.layout_sidebar(
                ui.sidebar(
                    ui.input_select(
                        "xy_var",
                        "Select Variable for X-Axis",
                        choices=["Miles_Driven", "Miles_Binned", "Brand"],
                        selected="Miles_Binned"
                    )
                ),
                ui.output_plot("xy_plot")
            )
        )
    ),
    title="Simulated Breakdown Data"
)

def server(input, output, session):
    # Set seed for reproducibility.
    np.random.seed(42)
    
    @reactive.Calc
    def simulated_data():
        n = input.numEvents()
        miles_driven = np.random.lognormal(mean=np.log(10000), sigma=0.5, size=n)
        brands = np.random.choice(
            ["Brand_A", "Brand_B", "Brand_C"],
            size=n,
            p=[0.4, 0.4, 0.2],
        )
        beta_miles = 0.000001
        brand_effects = {"Brand_A": 0.1, "Brand_B": 0.05, "Brand_C": -0.02}
        lambda_vals = np.exp(beta_miles * miles_driven + np.vectorize(brand_effects.get)(brands))
        breakdowns = np.random.poisson(lambda_vals)
        data = pd.DataFrame({
            "Miles_Driven": miles_driven,
            "Brand": brands,
            "Breakdowns": breakdowns,
        })
        # Bin miles into intervals of 10,000.
        data["Miles_Binned"] = (data["Miles_Driven"] // 10000) * 10000
        return data

    @reactive.Calc
    def grouped_table():
        data = simulated_data()
        covariates = input.covariates()
        group_cols = []
        if "Mileage" in covariates:
            group_cols.append("Miles_Binned")
        if "Brand" in covariates:
            group_cols.append("Brand")
        # Always include Breakdowns.
        group_cols.append("Breakdowns")
        
        grouped = data.groupby(group_cols).size().reset_index(name="Frequency")
        
        # Apply filtering if requested.
        filter_cov = input.filter_covariate()
        if filter_cov != "None":
            if filter_cov == "Mileage":
                filter_val = input.filter_value()
                if filter_val is not None:
                    grouped = grouped[grouped["Miles_Binned"] == float(filter_val)]
            elif filter_cov == "Brand":
                filter_val = input.filter_value()
                if filter_val is not None:
                    grouped = grouped[grouped["Brand"] == filter_val]
        
        total_freq = grouped["Frequency"].sum()
        if total_freq > 0:
            grouped["Probability"] = grouped["Frequency"] / total_freq
        else:
            grouped["Probability"] = 0
        return grouped

    @reactive.Calc
    def aggregated_for_xy():
        data = simulated_data()
        selected_var = input.xy_var()
        if selected_var == "Miles_Driven":
            # Use binned values for Miles_Driven.
            data = data.copy()
            data["Miles_Driven_Binned"] = data["Miles_Binned"]
            agg = data.groupby("Miles_Driven_Binned").agg(
                Total_Breakdowns=("Breakdowns", "sum"),
                Count=("Breakdowns", "count")
            ).reset_index().rename(columns={"Miles_Driven_Binned": selected_var})
        elif selected_var == "Miles_Binned":
            agg = data.groupby("Miles_Binned").agg(
                Total_Breakdowns=("Breakdowns", "sum"),
                Count=("Breakdowns", "count")
            ).reset_index().rename(columns={"Miles_Binned": selected_var})
        elif selected_var == "Brand":
            agg = data.groupby("Brand").agg(
                Total_Breakdowns=("Breakdowns", "sum"),
                Count=("Breakdowns", "count")
            ).reset_index().rename(columns={"Brand": selected_var})
        else:
            agg = data.groupby(selected_var).agg(
                Total_Breakdowns=("Breakdowns", "sum"),
                Count=("Breakdowns", "count")
            ).reset_index()
        return agg

    @output
    @render.table
    def results_table():
        return grouped_table()

    @output
    @render.ui
    def filter_value_ui():
        filter_cov = input.filter_covariate()
        if filter_cov == "Mileage":
            data = simulated_data()
            unique_bins = sorted(data["Miles_Binned"].unique())
            return ui.input_select(
                "filter_value",
                "Select Mileage Bin",
                choices=[str(int(x)) for x in unique_bins],
            )
        elif filter_cov == "Brand":
            return ui.input_select(
                "filter_value",
                "Select Brand",
                choices=["Brand_A", "Brand_B", "Brand_C"],
            )
        else:
            return ui.div()

    @output
    @render.plot
    def hist_plot():
        var = input.hist_var()
        data = simulated_data()
        fig, ax = plt.subplots()
        if var in ["Miles_Driven", "Miles_Binned", "Breakdowns"]:
            ax.hist(data[var], bins=20, color="skyblue", edgecolor="black")
            ax.set_xlabel(var)
            ax.set_ylabel("Frequency")
            ax.set_title(f"Histogram of {var}", fontsize=14)
        elif var == "Brand":
            counts = data[var].value_counts()
            ax.bar(counts.index, counts.values, color="skyblue", edgecolor="black")
            ax.set_xlabel(var)
            ax.set_ylabel("Count")
            ax.set_title(f"Bar Chart of {var}")
        return fig

    @output
    @render.plot
    def xy_plot():
        agg = aggregated_for_xy()
        var = input.xy_var()
        fig, ax = plt.subplots()
        if var == "Brand":
            ax.bar(agg[var], agg["Total_Breakdowns"], color="steelblue")
            ax.set_xlabel(var)
            ax.set_ylabel("Total Breakdowns")
            ax.set_title(f"{var} vs Total Breakdowns")
        else:
            ax.scatter(agg[var], agg["Total_Breakdowns"], color="steelblue")
            ax.set_xlabel(var)
            ax.set_ylabel("Total Breakdowns")
            ax.set_title(f"{var} vs Total Breakdowns")
        return fig

app = App(app_ui, server)
``` -->


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Footnotes</h2>

<ol>
<li id="fn1"><p>One of the common problems with the brevity of mathematical notation is its ambiguity. The statement P(D|M), the probability of the data given a model, can have what statisticians would call a Frequentist or a Bayesian interpretation. This primer assumes the Frequentist interpretation (as implied when we said we use ‘static’ models to generate data) until we get to more advanced topics, in which we will make the switch explicit. The Frequentist interpretation assumes point estimates of the parameters within our model, i.e.&nbsp;a single model that always generates data with the same parameters. We should note that this ‘static’ model can still generate data in a non-deterministic, i.e.&nbsp;probabilistic, way.</p>
<p>The other interpretation is the Bayesian one. In the Bayesian interpretation a model is not defined with point estimates of its parameters. The parameters themselves are given probability distributions reflecting the fact that they, in general, cannot be known with certainty. Thus when writing P(D|M) in a Bayesian framework it implies a model with a range of parameter values. There is also additional areas of ambiguity in this notation in the Bayesian approach due to the way P(M|D) is calculated and the way in which it ultimately relies on P(D|M)… We leave much of this for much more advanced textbooks, but will try to balance a reduction in ambiguity for the more advanced reader with simplicity for the more general reader.</p>
<p>Suffice it to say unless otherwise indicated, P(D|M) is to be interpreted in the most literal way, the probability of data given <strong>a</strong> model (note the emphasis on <strong>a</strong>, as in singular).<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>