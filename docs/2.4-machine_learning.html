<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Machine Learning – Statistics for Engineers in a Hurry (an Illustrated Primer)</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e8e9342e845377dfc7513ec3bb59cd67.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="mermaid-theme" content="neutral">
<script src="site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="site_libs/quarto-diagram/mermaid.css" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Statistics for Engineers in a Hurry (an Illustrated Primer)</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./2-data_generation.html">Probability of Data</a></li><li class="breadcrumb-item"><a href="./2.4-machine_learning.html">Machine Learning</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1-intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./2-data_generation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Probability of Data</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2.1-discrete_probability_distributions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Discrete Probability Distributions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2.2-continuous-probability-distributions.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Continuous Probability Distributions</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2.3-statistical_models.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Statistical Models</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2.4-machine_learning.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Machine Learning</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a href="./3-parameter_estimation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Likelihood of Model</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3.1-without_priors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Without Priors</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3.2-with_priors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">With Priors</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#preview" id="toc-preview" class="nav-link active" data-scroll-target="#preview">Preview</a>
  <ul class="collapse">
  <li><a href="#interactive-neural-network-visualization" id="toc-interactive-neural-network-visualization" class="nav-link" data-scroll-target="#interactive-neural-network-visualization">Interactive Neural Network Visualization</a></li>
  </ul></li>
  <li><a href="#statistical-models-vs.-machine-learning-models" id="toc-statistical-models-vs.-machine-learning-models" class="nav-link" data-scroll-target="#statistical-models-vs.-machine-learning-models">Statistical Models vs.&nbsp;Machine Learning Models</a>
  <ul class="collapse">
  <li><a href="#probabilistic-vs-deterministic-outputs" id="toc-probabilistic-vs-deterministic-outputs" class="nav-link" data-scroll-target="#probabilistic-vs-deterministic-outputs">Probabilistic vs Deterministic Outputs</a></li>
  <li><a href="#likelihood-vs-loss-function" id="toc-likelihood-vs-loss-function" class="nav-link" data-scroll-target="#likelihood-vs-loss-function">Likelihood vs Loss Function</a></li>
  <li><a href="#volume-of-data-and-number-of-parameters" id="toc-volume-of-data-and-number-of-parameters" class="nav-link" data-scroll-target="#volume-of-data-and-number-of-parameters">Volume of Data and Number of Parameters</a></li>
  </ul></li>
  <li><a href="#neural-nets" id="toc-neural-nets" class="nav-link" data-scroll-target="#neural-nets">Neural Nets</a></li>
  <li><a href="#single-neuron" id="toc-single-neuron" class="nav-link" data-scroll-target="#single-neuron">Single Neuron</a>
  <ul class="collapse">
  <li><a href="#activation-function" id="toc-activation-function" class="nav-link" data-scroll-target="#activation-function">Activation Function</a></li>
  </ul></li>
  <li><a href="#neural-net-structure" id="toc-neural-net-structure" class="nav-link" data-scroll-target="#neural-net-structure">Neural Net Structure</a>
  <ul class="collapse">
  <li><a href="#notation" id="toc-notation" class="nav-link" data-scroll-target="#notation">Notation</a></li>
  <li><a href="#the-input-layer" id="toc-the-input-layer" class="nav-link" data-scroll-target="#the-input-layer">The Input Layer</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./2-data_generation.html">Probability of Data</a></li><li class="breadcrumb-item"><a href="./2.4-machine_learning.html">Machine Learning</a></li></ol></nav>
<div class="quarto-title">
<h1 class="title">Machine Learning</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Warning
</div>
</div>
<div class="callout-body-container callout-body">
<p>This chapter is incomplete. It’s interesting material, but for the core purpose of the primer, it’s hard to prioritize for a v0 release.</p>
</div>
</div>
<section id="preview" class="level2">
<h2 class="anchored" data-anchor-id="preview">Preview</h2>
<p>Due to popular demand, we move on from traditional statistical models to those considered <em>machine learning</em>. We touch on the differences and similarities between the two categories before choosing to continue with a machine learning model that allows for statistical (i.e.&nbsp;probabilistic) interpretation.</p>
<p>Although the chapter is entitled Machine Learning, we make no attempt to cover the topic broadly. We simply choose a method that fits well in both statistical and machine learning contexts and explore it in detail. The resources for more comprehensive introductions to Machine Learning are easily found elsewhere.</p>
<p>The chapter is focused on [Bayesian] Neural Networks, and although they are an advanced topic, you may be surprised to learn the major building blocks have already been covered. In the flavor we use, each hidden layer neuron is just logistic regression (which is just generalized linear regression) built into a network. Once we build this network we will allow it to generate data like in previous chapters. We can choose to create ensembles of Neural Networks, or probabilistically sample likely parameter values, which will allow us to calculate P(D|M).</p>
<section id="interactive-neural-network-visualization" class="level3">
<h3 class="anchored" data-anchor-id="interactive-neural-network-visualization">Interactive Neural Network Visualization</h3>
<p>This visualization shows a neural network with 1 input (carat), 2 hidden layers (3 neurons each), and 1 output (price). The network performs regression with sigmoid-activated hidden layers.</p>
<style>
  .container {
    margin-top: 20px;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    margin-bottom: 1rem;
    padding: 1rem;
    background-color: #f5f5f5;
    border-radius: 4px;
  }
  .control {
    display: flex;
    flex-direction: column;
  }
  .control label {
    margin-bottom: 5px;
    font-weight: bold;
  }
  .tabs {
    display: flex;
    border-bottom: 1px solid #ccc;
    margin-top: 20px;
  }
  .tab {
    padding: 0.5rem 1rem;
    cursor: pointer;
    border: 1px solid transparent;
    border-bottom: none;
    margin-bottom: -1px;
  }
  .tab.active {
    border-color: #ccc;
    border-bottom-color: white;
    background-color: white;
  }
  .tab-content {
    display: none;
    padding: 1rem;
    border: 1px solid #ccc;
    border-top: none;
  }
  .tab-content.active {
    display: block;
  }
  table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 20px;
  }
  th, td {
    padding: 8px;
    text-align: left;
    border-bottom: 1px solid #ddd;
  }
  th {
    font-weight: bold;
  }
  .neuronsContainer {
    margin-top: 20px;
  }
</style>

<div class="controls">
  <div class="control">
    <label for="learningRate">Learning Rate: <span id="learningRateValue">0.01</span></label>
    <input type="range" id="learningRate" min="0.001" max="0.1" step="0.001" value="0.01">
  </div>
  <div class="control">
    <label for="epochs">Training Epochs: <span id="epochsValue">100</span></label>
    <input type="range" id="epochs" min="1" max="500" step="10" value="100">
  </div>
  <div class="control">
    <label for="trainingPct">Training Data %: <span id="trainingPctValue">70%</span></label>
    <input type="range" id="trainingPct" min="0.5" max="0.9" step="0.05" value="0.7">
  </div>
  <div class="control">
    <button id="trainButton">Train Network</button>
  </div>
</div>

<div class="tabs">
  <div class="tab active" data-tab="network">Neural Network</div>
  <div class="tab" data-tab="metrics">Performance Metrics</div>
  <div class="tab" data-tab="predictions">Predictions</div>
  <div class="tab" data-tab="data">Data</div>
</div>

<div id="network" class="tab-content active">
  <div id="neuralNetworkViz"></div>
</div>

<div id="metrics" class="tab-content">
  <div id="metricsTable"></div>
  <div id="trainingChart"></div>
</div>

<div id="predictions" class="tab-content">
  <div id="predictionsChart"></div>
</div>

<div id="data" class="tab-content">
  <div id="dataTable"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
<script>
  // Global variables
  let data = [];
  let trainingData = [];
  let testData = [];
  let network;
  let carat_mean, carat_std, price_mean, price_std;
  let trainingErrors = [];
  let predictionLine = [];
  let metrics = {};

  // Set up tabs
  document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
      
      tab.classList.add('active');
      document.getElementById(tab.dataset.tab).classList.add('active');
    });
  });

  // Set up sliders
  document.getElementById('learningRate').addEventListener('input', function() {
    document.getElementById('learningRateValue').textContent = this.value;
  });
  
  document.getElementById('epochs').addEventListener('input', function() {
    document.getElementById('epochsValue').textContent = this.value;
  });
  
  document.getElementById('trainingPct').addEventListener('input', function() {
    document.getElementById('trainingPctValue').textContent = (this.value * 100) + '%';
  });

  // Data from sampled_diamonds.csv (carat and price only)
  const sampleData = [
    { carat: 0.3, price: 545 },
    { carat: 0.3, price: 878 },
    { carat: 0.3, price: 590 },
    { carat: 0.3, price: 526 },
    { carat: 0.3, price: 776 },
    { carat: 0.27, price: 500 },
    { carat: 0.3, price: 540 },
    { carat: 0.3, price: 447 },
    { carat: 0.3, price: 605 },
    { carat: 0.3, price: 789 },
    { carat: 0.3, price: 421 },
    { carat: 0.3, price: 789 },
    { carat: 0.27, price: 567 },
    { carat: 0.3, price: 608 },
    { carat: 0.25, price: 575 },
    { carat: 0.3, price: 873 },
    { carat: 0.27, price: 682 },
    { carat: 0.3, price: 796 },
    { carat: 0.3, price: 608 },
    { carat: 0.3, price: 453 },
    { carat: 0.31, price: 544 },
    { carat: 0.31, price: 651 },
    { carat: 0.31, price: 979 },
    { carat: 0.31, price: 421 },
    { carat: 0.31, price: 914 },
    { carat: 0.31, price: 725 },
    { carat: 0.31, price: 921 },
    { carat: 0.31, price: 742 },
    { carat: 0.31, price: 802 },
    { carat: 0.31, price: 907 },
    { carat: 0.31, price: 625 },
    { carat: 0.31, price: 871 },
    { carat: 0.31, price: 462 },
    { carat: 0.31, price: 802 },
    { carat: 0.31, price: 802 },
    { carat: 0.31, price: 523 },
    { carat: 0.31, price: 1046 },
    { carat: 0.31, price: 507 },
    { carat: 0.31, price: 816 },
    { carat: 0.31, price: 891 },
    { carat: 0.32, price: 990 },
    { carat: 0.32, price: 828 },
    { carat: 0.32, price: 645 },
    { carat: 0.32, price: 814 },
    { carat: 0.32, price: 477 },
    { carat: 0.32, price: 477 },
    { carat: 0.32, price: 602 },
    { carat: 0.32, price: 449 },
    { carat: 0.32, price: 442 },
    { carat: 0.32, price: 720 },
    { carat: 0.32, price: 528 },
    { carat: 0.32, price: 803 },
    { carat: 0.32, price: 421 },
    { carat: 0.32, price: 854 },
    { carat: 0.32, price: 653 },
    { carat: 0.32, price: 716 },
    { carat: 0.32, price: 720 },
    { carat: 0.32, price: 758 },
    { carat: 0.32, price: 918 },
    { carat: 0.32, price: 544 },
    { carat: 0.33, price: 797 },
    { carat: 0.33, price: 713 },
    { carat: 0.33, price: 984 },
    { carat: 0.33, price: 1312 },
    { carat: 0.34, price: 727 },
    { carat: 0.33, price: 631 },
    { carat: 0.35, price: 620 },
    { carat: 0.34, price: 760 },
    { carat: 0.35, price: 868 },
    { carat: 0.35, price: 601 },
    { carat: 0.34, price: 961 },
    { carat: 0.33, price: 965 },
    { carat: 0.33, price: 743 },
    { carat: 0.34, price: 477 },
    { carat: 0.33, price: 854 },
    { carat: 0.35, price: 738 },
    { carat: 0.35, price: 820 },
    { carat: 0.35, price: 644 },
    { carat: 0.33, price: 646 },
    { carat: 0.33, price: 854 },
    { carat: 0.4, price: 666 },
    { carat: 0.4, price: 1080 },
    { carat: 0.36, price: 835 },
    { carat: 0.4, price: 945 },
    { carat: 0.4, price: 982 },
    { carat: 0.38, price: 1257 },
    { carat: 0.4, price: 912 },
    { carat: 0.37, price: 649 },
    { carat: 0.4, price: 1238 },
    { carat: 0.38, price: 998 },
    { carat: 0.37, price: 936 },
    { carat: 0.4, price: 980 },
    { carat: 0.36, price: 1018 },
    { carat: 0.38, price: 899 },
    { carat: 0.37, price: 749 },
    { carat: 0.4, price: 737 },
    { carat: 0.37, price: 491 },
    { carat: 0.4, price: 737 },
    { carat: 0.39, price: 614 },
    { carat: 0.38, price: 898 },
    { carat: 0.41, price: 827 },
    { carat: 0.41, price: 1079 },
    { carat: 0.42, price: 773 },
    { carat: 0.41, price: 844 },
    { carat: 0.41, price: 1243 },
    { carat: 0.41, price: 1286 },
    { carat: 0.41, price: 719 },
    { carat: 0.41, price: 1230 },
    { carat: 0.41, price: 904 },
    { carat: 0.41, price: 638 },
    { carat: 0.42, price: 898 },
    { carat: 0.41, price: 969 },
    { carat: 0.42, price: 963 },
    { carat: 0.41, price: 671 },
    { carat: 0.42, price: 1400 },
    { carat: 0.41, price: 1186 },
    { carat: 0.42, price: 992 },
    { carat: 0.41, price: 1122 },
    { carat: 0.41, price: 1007 },
    { carat: 0.41, price: 1076 },
    { carat: 0.5, price: 1747 },
    { carat: 0.45, price: 1046 },
    { carat: 0.46, price: 1227 },
    { carat: 0.5, price: 2243 },
    { carat: 0.5, price: 1415 },
    { carat: 0.43, price: 894 },
    { carat: 0.44, price: 1253 },
    { carat: 0.5, price: 978 },
    { carat: 0.5, price: 982 },
    { carat: 0.5, price: 1015 },
    { carat: 0.43, price: 813 },
    { carat: 0.46, price: 1412 },
    { carat: 0.5, price: 1624 },
    { carat: 0.43, price: 792 },
    { carat: 0.5, price: 1080 },
    { carat: 0.46, price: 1299 },
    { carat: 0.5, price: 2070 },
    { carat: 0.48, price: 1088 },
    { carat: 0.5, price: 1819 },
    { carat: 0.47, price: 1021 },
    { carat: 0.51, price: 2146 },
    { carat: 0.53, price: 1070 },
    { carat: 0.53, price: 1607 },
    { carat: 0.53, price: 1881 },
    { carat: 0.53, price: 1607 },
    { carat: 0.51, price: 2185 },
    { carat: 0.51, price: 1204 },
    { carat: 0.52, price: 1878 },
    { carat: 0.52, price: 1988 },
    { carat: 0.52, price: 1227 },
    { carat: 0.51, price: 2041 },
    { carat: 0.53, price: 1395 },
    { carat: 0.51, price: 1781 },
    { carat: 0.52, price: 1385 },
    { carat: 0.51, price: 959 },
    { carat: 0.51, price: 1577 },
    { carat: 0.52, price: 971 },
    { carat: 0.52, price: 1936 },
    { carat: 0.51, price: 1574 },
    { carat: 0.51, price: 1776 },
    { carat: 0.54, price: 1774 },
    { carat: 0.54, price: 2202 },
    { carat: 0.58, price: 1430 },
    { carat: 0.56, price: 1819 },
    { carat: 0.54, price: 1259 },
    { carat: 0.59, price: 1265 },
    { carat: 0.55, price: 2030 },
    { carat: 0.54, price: 2479 },
    { carat: 0.56, price: 2118 },
    { carat: 0.55, price: 2499 },
    { carat: 0.54, price: 2271 },
    { carat: 0.54, price: 1725 },
    { carat: 0.54, price: 1772 },
    { carat: 0.56, price: 1712 },
    { carat: 0.58, price: 1761 },
    { carat: 0.6, price: 1250 },
    { carat: 0.59, price: 1652 },
    { carat: 0.54, price: 1392 },
    { carat: 0.56, price: 1698 },
    { carat: 0.56, price: 1287 },
    { carat: 0.7, price: 3359 },
    { carat: 0.7, price: 2362 },
    { carat: 0.7, price: 2317 },
    { carat: 0.63, price: 1736 },
    { carat: 0.7, price: 2730 },
    { carat: 0.7, price: 3001 },
    { carat: 0.7, price: 3201 },
    { carat: 0.7, price: 2563 },
    { carat: 0.7, price: 2525 },
    { carat: 0.7, price: 2473 },
    { carat: 0.7, price: 1564 },
    { carat: 0.64, price: 1811 },
    { carat: 0.7, price: 1843 },
    { carat: 0.63, price: 3181 },
    { carat: 0.7, price: 2039 },
    { carat: 0.7, price: 2394 },
    { carat: 0.7, price: 1749 },
    { carat: 0.7, price: 2176 },
    { carat: 0.7, price: 2444 },
    { carat: 0.7, price: 3300 },
    { carat: 0.71, price: 2795 },
    { carat: 0.71, price: 2863 },
    { carat: 0.72, price: 2583 },
    { carat: 0.72, price: 2889 },
    { carat: 0.71, price: 2400 },
    { carat: 0.72, price: 1942 },
    { carat: 0.72, price: 2398 },
    { carat: 0.72, price: 3465 },
    { carat: 0.71, price: 2343 },
    { carat: 0.71, price: 2853 },
    { carat: 0.72, price: 2311 },
    { carat: 0.71, price: 1717 },
    { carat: 0.72, price: 2148 },
    { carat: 0.72, price: 3124 },
    { carat: 0.71, price: 2930 },
    { carat: 0.71, price: 2294 },
    { carat: 0.71, price: 2633 },
    { carat: 0.71, price: 2036 },
    { carat: 0.71, price: 3431 },
    { carat: 0.71, price: 2423 },
    { carat: 0.74, price: 2709 },
    { carat: 0.9, price: 4198 },
    { carat: 0.9, price: 4314 },
    { carat: 0.9, price: 4435 },
    { carat: 0.8, price: 2914 },
    { carat: 0.75, price: 2613 },
    { carat: 0.76, price: 2937 },
    { carat: 0.78, price: 2834 },
    { carat: 0.74, price: 1913 },
    { carat: 0.77, price: 2988 },
    { carat: 0.76, price: 2680 },
    { carat: 0.84, price: 3577 },
    { carat: 0.76, price: 3671 },
    { carat: 0.78, price: 3055 },
    { carat: 0.75, price: 2850 },
    { carat: 0.9, price: 2761 },
    { carat: 0.9, price: 3350 },
    { carat: 0.9, price: 4592 },
    { carat: 0.83, price: 2666 },
    { carat: 0.74, price: 3537 },
    { carat: 0.91, price: 3567 },
    { carat: 1.0, price: 4626 },
    { carat: 0.95, price: 4341 },
    { carat: 1.0, price: 5914 },
    { carat: 1.0, price: 5148 },
    { carat: 1.0, price: 3465 },
    { carat: 0.97, price: 4063 },
    { carat: 1.0, price: 4626 },
    { carat: 0.92, price: 3684 },
    { carat: 1.0, price: 4816 },
    { carat: 0.91, price: 4668 },
    { carat: 1.0, price: 5484 },
    { carat: 1.0, price: 7500 },
    { carat: 0.91, price: 3423 },
    { carat: 1.0, price: 3830 },
    { carat: 1.0, price: 6377 },
    { carat: 1.0, price: 4861 },
    { carat: 1.0, price: 3920 },
    { carat: 0.91, price: 4389 },
    { carat: 0.91, price: 3546 },
    { carat: 1.01, price: 4588 },
    { carat: 1.01, price: 4821 },
    { carat: 1.01, price: 6097 },
    { carat: 1.01, price: 3945 },
    { carat: 1.01, price: 4559 },
    { carat: 1.01, price: 6075 },
    { carat: 1.01, price: 4276 },
    { carat: 1.01, price: 4513 },
    { carat: 1.01, price: 6295 },
    { carat: 1.01, price: 4989 },
    { carat: 1.01, price: 6105 },
    { carat: 1.01, price: 4899 },
    { carat: 1.01, price: 3682 },
    { carat: 1.01, price: 7652 },
    { carat: 1.01, price: 6221 },
    { carat: 1.01, price: 6516 },
    { carat: 1.01, price: 4916 },
    { carat: 1.01, price: 6697 },
    { carat: 1.01, price: 4977 },
    { carat: 1.01, price: 5543 },
    { carat: 1.02, price: 5553 },
    { carat: 1.03, price: 4522 },
    { carat: 1.02, price: 4540 },
    { carat: 1.03, price: 4764 },
    { carat: 1.02, price: 5287 },
    { carat: 1.02, price: 6169 },
    { carat: 1.03, price: 4401 },
    { carat: 1.04, price: 7220 },
    { carat: 1.04, price: 4181 },
    { carat: 1.03, price: 6783 },
    { carat: 1.02, price: 4958 },
    { carat: 1.03, price: 3922 },
    { carat: 1.02, price: 6047 },
    { carat: 1.04, price: 4240 },
    { carat: 1.03, price: 5804 },
    { carat: 1.02, price: 4449 },
    { carat: 1.02, price: 4162 },
    { carat: 1.03, price: 9881 },
    { carat: 1.04, price: 2037 },
    { carat: 1.02, price: 6652 },
    { carat: 1.09, price: 6225 },
    { carat: 1.11, price: 7639 },
    { carat: 1.06, price: 4255 },
    { carat: 1.06, price: 4452 },
    { carat: 1.11, price: 8843 },
    { carat: 1.13, price: 5526 },
    { carat: 1.07, price: 5093 },
    { carat: 1.09, price: 8454 },
    { carat: 1.08, price: 6769 },
    { carat: 1.05, price: 6181 },
    { carat: 1.09, price: 6934 },
    { carat: 1.11, price: 5962 },
    { carat: 1.07, price: 9532 },
    { carat: 1.13, price: 3669 },
    { carat: 1.1, price: 6535 },
    { carat: 1.05, price: 5101 },
    { carat: 1.07, price: 6730 },
    { carat: 1.12, price: 9634 },
    { carat: 1.09, price: 4372 },
    { carat: 1.12, price: 7716 },
    { carat: 1.16, price: 5678 },
    { carat: 1.23, price: 8855 },
    { carat: 1.15, price: 5257 },
    { carat: 1.2, price: 5699 },
    { carat: 1.2, price: 11021 },
    { carat: 1.21, price: 4472 },
    { carat: 1.24, price: 7701 },
    { carat: 1.2, price: 16256 },
    { carat: 1.24, price: 8584 },
    { carat: 1.24, price: 5221 },
    { carat: 1.21, price: 6092 },
    { carat: 1.22, price: 7738 },
    { carat: 1.2, price: 6416 },
    { carat: 1.21, price: 4791 },
    { carat: 1.2, price: 5226 },
    { carat: 1.21, price: 4310 },
    { carat: 1.21, price: 11572 },
    { carat: 1.22, price: 8975 },
    { carat: 1.2, price: 8545 },
    { carat: 1.2, price: 6250 },
    { carat: 1.51, price: 12831 },
    { carat: 1.5, price: 15240 },
    { carat: 1.5, price: 13528 },
    { carat: 1.25, price: 3990 },
    { carat: 1.25, price: 4900 },
    { carat: 1.4, price: 5723 },
    { carat: 1.26, price: 6277 },
    { carat: 1.26, price: 5306 },
    { carat: 1.5, price: 9533 },
    { carat: 1.5, price: 10428 },
    { carat: 1.5, price: 8770 },
    { carat: 1.5, price: 8490 },
    { carat: 1.5, price: 6770 },
    { carat: 1.5, price: 8161 },
    { carat: 1.33, price: 7982 },
    { carat: 1.32, price: 6079 },
    { carat: 1.5, price: 12247 },
    { carat: 1.33, price: 6482 },
    { carat: 1.51, price: 9116 },
    { carat: 1.25, price: 9933 },
    { carat: 1.7, price: 13823 },
    { carat: 1.62, price: 12429 },
    { carat: 1.52, price: 10664 },
    { carat: 1.52, price: 10968 },
    { carat: 1.55, price: 8056 },
    { carat: 1.54, price: 8652 },
    { carat: 1.53, price: 12791 },
    { carat: 1.54, price: 9285 },
    { carat: 1.67, price: 11400 },
    { carat: 1.56, price: 8048 },
    { carat: 1.56, price: 8324 },
    { carat: 1.52, price: 13799 },
    { carat: 1.7, price: 17892 },
    { carat: 1.7, price: 18279 },
    { carat: 1.7, price: 13737 },
    { carat: 1.7, price: 12190 },
    { carat: 1.7, price: 6397 },
    { carat: 1.52, price: 13768 },
    { carat: 1.55, price: 8678 },
    { carat: 1.53, price: 7240 },
    { carat: 2.14, price: 12400 },
    { carat: 1.71, price: 13097 },
    { carat: 2.0, price: 11036 },
    { carat: 2.32, price: 18026 },
    { carat: 2.0, price: 15312 },
    { carat: 1.73, price: 9271 },
    { carat: 2.3, price: 12316 },
    { carat: 2.06, price: 14982 },
    { carat: 2.01, price: 14998 },
    { carat: 2.05, price: 16357 },
    { carat: 2.02, price: 15996 },
    { carat: 1.71, price: 9193 },
    { carat: 2.02, price: 10412 },
    { carat: 2.15, price: 17221 },
    { carat: 1.77, price: 15278 },
    { carat: 2.28, price: 16369 },
    { carat: 1.75, price: 9890 },
    { carat: 2.06, price: 13317 }
  ];

  // Activation functions
  function sigmoid(x) {
    return 1 / (1 + Math.exp(-x));
  }

  function dsigmoid(y) {
    return y * (1 - y);
  }

  // Neural Network class
  class NeuralNetwork {
    constructor(learningRate) {
      // Architecture: 1 input, 2 hidden layers with 3 neurons each, 1 output
      this.weights = {
        // Input to hidden layer 1
        ih1: Array.from({length: 3}, () => Array.from({length: 1}, () => Math.random() * 2 - 1)),
        // Hidden layer 1 to hidden layer 2
        h1h2: Array.from({length: 3}, () => Array.from({length: 3}, () => Math.random() * 2 - 1)),
        // Hidden layer 2 to output
        h2o: Array.from({length: 1}, () => Array.from({length: 3}, () => Math.random() * 2 - 1))
      };
      
      this.biases = {
        h1: Array.from({length: 3}, () => Math.random() * 2 - 1),
        h2: Array.from({length: 3}, () => Math.random() * 2 - 1),
        o: Array.from({length: 1}, () => Math.random() * 2 - 1)
      };
      
      this.learning_rate = learningRate;
    }
    
    feedforward(input) {
      // Nodes in hidden layer 1
      const hidden1 = Array(3).fill(0);
      for (let i = 0; i < 3; i++) {
        let sum = this.biases.h1[i];
        sum += input * this.weights.ih1[i][0];
        hidden1[i] = sigmoid(sum);
      }
      
      // Nodes in hidden layer 2
      const hidden2 = Array(3).fill(0);
      for (let i = 0; i < 3; i++) {
        let sum = this.biases.h2[i];
        for (let j = 0; j < 3; j++) {
          sum += hidden1[j] * this.weights.h1h2[i][j];
        }
        hidden2[i] = sigmoid(sum);
      }
      
      // Output layer (linear activation)
      let output = this.biases.o[0];
      for (let i = 0; i < 3; i++) {
        output += hidden2[i] * this.weights.h2o[0][i];
      }
      
      return {
        input: input,
        hidden1: hidden1,
        hidden2: hidden2,
        output: output
      };
    }
    
    train(input, target) {
      // Feedforward
      const result = this.feedforward(input);
      const { hidden1, hidden2, output } = result;
      
      // Calculate errors
      // Output error
      const output_error = target - output;
      
      // Hidden layer 2 error
      const hidden2_error = Array(3).fill(0);
      for (let i = 0; i < 3; i++) {
        hidden2_error[i] = output_error * this.weights.h2o[0][i];
      }
      
      // Hidden layer 1 error
      const hidden1_error = Array(3).fill(0);
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          hidden1_error[i] += hidden2_error[j] * this.weights.h1h2[j][i];
        }
      }
      
      // Backpropagation
      // Update weights and biases for output layer
      for (let i = 0; i < 3; i++) {
        this.weights.h2o[0][i] += this.learning_rate * output_error * hidden2[i];
      }
      this.biases.o[0] += this.learning_rate * output_error;
      
      // Update weights and biases for hidden layer 2
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
          this.weights.h1h2[i][j] += this.learning_rate * hidden2_error[i] * dsigmoid(hidden2[i]) * hidden1[j];
        }
        this.biases.h2[i] += this.learning_rate * hidden2_error[i] * dsigmoid(hidden2[i]);
      }
      
      // Update weights and biases for hidden layer 1
      for (let i = 0; i < 3; i++) {
        this.weights.ih1[i][0] += this.learning_rate * hidden1_error[i] * dsigmoid(hidden1[i]) * input;
        this.biases.h1[i] += this.learning_rate * hidden1_error[i] * dsigmoid(hidden1[i]);
      }
      
      return output_error;
    }
  }

  // Initialize data
  function initializeData() {
    data = sampleData;
    
    // Calculate statistics
    carat_mean = data.reduce((sum, d) => sum + d.carat, 0) / data.length;
    price_mean = data.reduce((sum, d) => sum + d.price, 0) / data.length;
    
    carat_std = Math.sqrt(data.reduce((sum, d) => sum + Math.pow(d.carat - carat_mean, 2), 0) / data.length);
    price_std = Math.sqrt(data.reduce((sum, d) => sum + Math.pow(d.price - price_mean, 2), 0) / data.length);
    
    // Normalize data
    const normalizedData = data.map(d => ({
      carat: (d.carat - carat_mean) / carat_std,
      price: (d.price - price_mean) / price_std,
      carat_raw: d.carat,
      price_raw: d.price
    }));
    
    // Split data
    const trainingPct = parseFloat(document.getElementById('trainingPct').value);
    const shuffled = [...normalizedData].sort(() => Math.random() - 0.5);
    const splitIndex = Math.floor(shuffled.length * trainingPct);
    trainingData = shuffled.slice(0, splitIndex);
    testData = shuffled.slice(splitIndex);
    
    // Show data table
    createDataTable();
  }

  // Create data table
  function createDataTable() {
    const table = document.createElement('table');
    
    // Create header
    const thead = document.createElement('thead');
    const headerRow = document.createElement('tr');
    
    const th1 = document.createElement('th');
    th1.textContent = 'Carat';
    headerRow.appendChild(th1);
    
    const th2 = document.createElement('th');
    th2.textContent = 'Price';
    headerRow.appendChild(th2);
    
    thead.appendChild(headerRow);
    table.appendChild(thead);
    
    // Create body
    const tbody = document.createElement('tbody');
    
    // Show first 20 rows
    const displayData = data.slice(0, 20);
    displayData.forEach(d => {
      const row = document.createElement('tr');
      
      const td1 = document.createElement('td');
      td1.textContent = d.carat.toFixed(2);
      row.appendChild(td1);
      
      const td2 = document.createElement('td');
      td2.textContent = '$' + d.price.toFixed(0);
      row.appendChild(td2);
      
      tbody.appendChild(row);
    });
    
    table.appendChild(tbody);
    
    // Add to page
    const dataTableDiv = document.getElementById('dataTable');
    dataTableDiv.innerHTML = '';
    dataTableDiv.appendChild(table);
  }

  // Train the neural network
  function trainNetwork() {
    const learningRate = parseFloat(document.getElementById('learningRate').value);
    const epochs = parseInt(document.getElementById('epochs').value);
    
    network = new NeuralNetwork(learningRate);
    trainingErrors = [];
    
    const startTime = Date.now();
    
    // Training loop
    for (let epoch = 0; epoch < epochs; epoch++) {
      let sumError = 0;
      
      for (const d of trainingData) {
        const error = network.train(d.carat, d.price);
        sumError += error * error;
      }
      
      const mse = sumError / trainingData.length;
      trainingErrors.push({
        epoch: epoch,
        error: Math.sqrt(mse)
      });
    }
    
    const endTime = Date.now();
    
    // Calculate metrics
    // RMSE
    let sumSqError = 0;
    for (const d of testData) {
      const { output } = network.feedforward(d.carat);
      sumSqError += Math.pow(d.price - output, 2);
    }
    const testRmse = Math.sqrt(sumSqError / testData.length);
    
    // R-squared
    const predictions = testData.map(d => {
      const normalizedCarat = (d.carat_raw - carat_mean) / carat_std;
      const normalizedPrediction = network.feedforward(normalizedCarat).output;
      return normalizedPrediction * price_std + price_mean;
    });
    
    const meanPrice = testData.reduce((sum, d) => sum + d.price_raw, 0) / testData.length;
    const totalSumSquares = testData.reduce((sum, d) => sum + Math.pow(d.price_raw - meanPrice, 2), 0);
    const residualSumSquares = testData.reduce((sum, d, i) => sum + Math.pow(d.price_raw - predictions[i], 2), 0);
    const rSquared = 1 - (residualSumSquares / totalSumSquares);
    
    metrics = {
      rmse: testRmse * price_std,
      rSquared: rSquared,
      trainingTime: endTime - startTime
    };
    
    // Generate prediction line
    const caratMin = Math.min(...data.map(d => d.carat));
    const caratMax = Math.max(...data.map(d => d.carat));
    const step = (caratMax - caratMin) / 50;
    
    predictionLine = [];
    for (let carat = caratMin; carat <= caratMax; carat += step) {
      const normalizedCarat = (carat - carat_mean) / carat_std;
      const normalizedPrediction = network.feedforward(normalizedCarat).output;
      const prediction = normalizedPrediction * price_std + price_mean;
      
      predictionLine.push({
        carat: carat,
        price: prediction
      });
    }
    
    // Update visualizations
    createNeuralNetworkViz();
    createMetricsViz();
    createPredictionsViz();
  }

  // Create neural network visualization
  function createNeuralNetworkViz() {
    const width = 800;
    const height = 400;
    const margin = { top: 40, right: 40, bottom: 40, left: 40 };
    
    // Clear previous visualization
    const container = document.getElementById('neuralNetworkViz');
    container.innerHTML = '';
    
    // Create SVG
    const svg = d3.create('svg')
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', [0, 0, width, height])
      .attr('style', 'max-width: 100%; height: auto;');
    
    // Layer coordinates
    const layers = [
      { name: 'Input', nodes: 1, x: margin.left + 50 },
      { name: 'Hidden 1', nodes: 3, x: margin.left + 230 },
      { name: 'Hidden 2', nodes: 3, x: margin.left + 410 },
      { name: 'Output', nodes: 1, x: margin.left + 590 }
    ];
    
    // Add layer labels
    svg.selectAll('.layer-label')
      .data(layers)
      .join('text')
      .attr('class', 'layer-label')
      .attr('x', d => d.x)
      .attr('y', margin.top - 15)
      .attr('text-anchor', 'middle')
      .attr('font-weight', 'bold')
      .text(d => d.name);
    
    // Function to get node vertical position
    function getNodeY(layerIndex, nodeIndex, layerNodes) {
      const layerHeight = height - margin.top - margin.bottom;
      const nodeSpacing = layerHeight / (layerNodes + 1);
      return margin.top + nodeSpacing * (nodeIndex + 1);
    }
    
    // Create all nodes
    const nodeData = [];
    const connections = [];
    
    layers.forEach((layer, layerIndex) => {
      for (let i = 0; i < layer.nodes; i++) {
        const nodeY = getNodeY(layerIndex, i, layer.nodes);
        
        nodeData.push({
          id: `${layerIndex}-${i}`,
          x: layer.x,
          y: nodeY,
          layer: layerIndex,
          index: i
        });
        
        // Create connections
        if (layerIndex > 0) {
          const prevLayer = layers[layerIndex - 1];
          for (let j = 0; j < prevLayer.nodes; j++) {
            let weight;
            if (layerIndex === 1) {
              weight = network.weights.ih1[i][j];
            } else if (layerIndex === 2) {
              weight = network.weights.h1h2[i][j];
            } else if (layerIndex === 3) {
              weight = network.weights.h2o[i][j];
            }
            
            connections.push({
              source: `${layerIndex-1}-${j}`,
              target: `${layerIndex}-${i}`,
              weight: weight
            });
          }
        }
      }
    });
    
    // Draw connections
    svg.append('g')
      .attr('class', 'connections')
      .selectAll('line')
      .data(connections)
      .join('line')
      .attr('x1', d => nodeData.find(n => n.id === d.source).x)
      .attr('y1', d => nodeData.find(n => n.id === d.source).y)
      .attr('x2', d => nodeData.find(n => n.id === d.target).x)
      .attr('y2', d => nodeData.find(n => n.id === d.target).y)
      .attr('stroke', d => d.weight > 0 ? 'blue' : 'red')
      .attr('stroke-width', d => Math.abs(d.weight) * 3 + 0.5)
      .attr('opacity', 0.6);
    
    // Draw nodes
    const nodeGroup = svg.append('g').attr('class', 'nodes');
    
    nodeGroup.selectAll('circle')
      .data(nodeData)
      .join('circle')
      .attr('cx', d => d.x)
      .attr('cy', d => d.y)
      .attr('r', 25)
      .attr('fill', d => {
        if (d.layer === 0) return '#8dd3c7';  // Input (teal)
        if (d.layer === 3) return '#fb8072';  // Output (red)
        return '#80b1d3';                     // Hidden (blue)
      })
      .attr('stroke', 'black')
      .attr('stroke-width', 2);
    
    // Add bias and weight labels
    nodeGroup.selectAll('text.node-label')
      .data(nodeData)
      .join('text')
      .attr('class', 'node-label')
      .attr('x', d => d.x)
      .attr('y', d => d.y)
      .attr('text-anchor', 'middle')
      .attr('dominant-baseline', 'middle')
      .attr('font-size', '12px')
      .attr('font-weight', 'bold')
      .text(d => {
        if (d.layer === 0) return 'Carat';
        if (d.layer === 3) return 'Price';
        
        // Get bias for hidden nodes
        let bias;
        if (d.layer === 1) bias = network.biases.h1[d.index];
        if (d.layer === 2) bias = network.biases.h2[d.index];
        
        return `b:${bias.toFixed(2)}`;
      });
    
    // Add weight labels to connections
    svg.append('g')
      .attr('class', 'weight-labels')
      .selectAll('text')
      .data(connections)
      .join('text')
      .attr('x', d => {
        const source = nodeData.find(n => n.id === d.source);
        const target = nodeData.find(n => n.id === d.target);
        return (source.x + target.x) / 2;
      })
      .attr('y', d => {
        const source = nodeData.find(n => n.id === d.source);
        const target = nodeData.find(n => n.id === d.target);
        return (source.y + target.y) / 2 - 8;
      })
      .attr('text-anchor', 'middle')
      .attr('font-size', '10px')
      .text(d => d.weight.toFixed(2));
    
    container.appendChild(svg.node());
  }

  // Create metrics visualization
  function createMetricsViz() {
    // Create metrics table
    const tableContainer = document.getElementById('metricsTable');
    tableContainer.innerHTML = '';
    
    const table = document.createElement('table');
    const tbody = document.createElement('tbody');
    
    // RMSE
    const row1 = document.createElement('tr');
    const cell1_1 = document.createElement('td');
    cell1_1.textContent = 'Test RMSE';
    const cell1_2 = document.createElement('td');
    cell1_2.textContent = `$${metrics.rmse.toFixed(2)}`;
    cell1_2.style.textAlign = 'right';
    row1.appendChild(cell1_1);
    row1.appendChild(cell1_2);
    tbody.appendChild(row1);
    
    // R-squared
    const row2 = document.createElement('tr');
    const cell2_1 = document.createElement('td');
    cell2_1.textContent = 'R² Score';
    const cell2_2 = document.createElement('td');
    cell2_2.textContent = metrics.rSquared.toFixed(4);
    cell2_2.style.textAlign = 'right';
    row2.appendChild(cell2_1);
    row2.appendChild(cell2_2);
    tbody.appendChild(row2);
    
    // Training time
    const row3 = document.createElement('tr');
    const cell3_1 = document.createElement('td');
    cell3_1.textContent = 'Training Time';
    const cell3_2 = document.createElement('td');
    cell3_2.textContent = `${metrics.trainingTime}ms`;
    cell3_2.style.textAlign = 'right';
    row3.appendChild(cell3_1);
    row3.appendChild(cell3_2);
    tbody.appendChild(row3);
    
    table.appendChild(tbody);
    tableContainer.appendChild(table);
    
    // Create training error chart
    const chartContainer = document.getElementById('trainingChart');
    chartContainer.innerHTML = '';
    
    const width = 600;
    const height = 300;
    const margin = { top: 40, right: 30, bottom: 40, left: 60 };
    
    const svg = d3.create('svg')
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', [0, 0, width, height])
      .attr('style', 'max-width: 100%; height: auto;');
    
    // Add title
    svg.append('text')
      .attr('x', width / 2)
      .attr('y', margin.top / 2)
      .attr('text-anchor', 'middle')
      .attr('font-weight', 'bold')
      .text('Training Error Over Epochs');
    
    // Create scales
    const x = d3.scaleLinear()
      .domain([0, d3.max(trainingErrors, d => d.epoch)])
      .range([margin.left, width - margin.right]);
    
    const y = d3.scaleLinear()
      .domain([0, d3.max(trainingErrors, d => d.error) * 1.1])
      .range([height - margin.bottom, margin.top]);
    
    // Add axes
    svg.append('g')
      .attr('transform', `translate(0,${height - margin.bottom})`)
      .call(d3.axisBottom(x).ticks(5))
      .append('text')
      .attr('x', width - margin.right)
      .attr('y', 30)
      .attr('fill', 'black')
      .text('Epoch');
    
    svg.append('g')
      .attr('transform', `translate(${margin.left},0)`)
      .call(d3.axisLeft(y))
      .append('text')
      .attr('transform', 'rotate(-90)')
      .attr('x', -height / 2)
      .attr('y', -40)
      .attr('fill', 'black')
      .attr('text-anchor', 'middle')
      .text('RMSE');
    
    // Create line
    const line = d3.line()
      .x(d => x(d.epoch))
      .y(d => y(d.error));
    
    // Add the line
    svg.append('path')
      .datum(trainingErrors)
      .attr('fill', 'none')
      .attr('stroke', 'steelblue')
      .attr('stroke-width', 1.5)
      .attr('d', line);
    
    chartContainer.appendChild(svg.node());
  }

  // Create predictions visualization
  function createPredictionsViz() {
    const container = document.getElementById('predictionsChart');
    container.innerHTML = '';
    
    const width = 600;
    const height = 400;
    const margin = { top: 40, right: 30, bottom: 40, left: 60 };
    
    const svg = d3.create('svg')
      .attr('width', width)
      .attr('height', height)
      .attr('viewBox', [0, 0, width, height])
      .attr('style', 'max-width: 100%; height: auto;');
    
    // Create scales
    const x = d3.scaleLinear()
      .domain([d3.min(data, d => d.carat), d3.max(data, d => d.carat)])
      .range([margin.left, width - margin.right]);
    
    const y = d3.scaleLinear()
      .domain([0, d3.max(data, d => d.price) * 1.1])
      .range([height - margin.bottom, margin.top]);
    
    // Add axes
    svg.append('g')
      .attr('transform', `translate(0,${height - margin.bottom})`)
      .call(d3.axisBottom(x))
      .append('text')
      .attr('x', width - margin.right)
      .attr('y', 30)
      .attr('fill', 'black')
      .text('Carat');
    
    svg.append('g')
      .attr('transform', `translate(${margin.left},0)`)
      .call(d3.axisLeft(y))
      .append('text')
      .attr('transform', 'rotate(-90)')
      .attr('x', -height / 2)
      .attr('y', -40)
      .attr('fill', 'black')
      .attr('text-anchor', 'middle')
      .text('Price ($)');
    
    // Add grid
    svg.append('g')
      .attr('stroke', 'lightgray')
      .attr('stroke-opacity', 0.3)
      .call(g => g.append('g')
        .selectAll('line')
        .data(x.ticks(10))
        .join('line')
        .attr('x1', d => x(d))
        .attr('x2', d => x(d))
        .attr('y1', margin.top)
        .attr('y2', height - margin.bottom))
      .call(g => g.append('g')
        .selectAll('line')
        .data(y.ticks(10))
        .join('line')
        .attr('y1', d => y(d))
        .attr('y2', d => y(d))
        .attr('x1', margin.left)
        .attr('x2', width - margin.right));
    
    // Draw test data points
    svg.append('g')
      .selectAll('circle.test')
      .data(testData)
      .join('circle')
      .attr('class', 'test')
      .attr('cx', d => x(d.carat_raw))
      .attr('cy', d => y(d.price_raw))
      .attr('r', 3)
      .attr('fill', 'gray')
      .attr('opacity', 0.5);
    
    // Draw prediction line
    const line = d3.line()
      .x(d => x(d.carat))
      .y(d => y(d.price));
    
    svg.append('path')
      .datum(predictionLine)
      .attr('fill', 'none')
      .attr('stroke', 'red')
      .attr('stroke-width', 2)
      .attr('d', line);
    
    // Add legend
    const legend = svg.append('g')
      .attr('transform', `translate(${width - 120}, ${margin.top + 20})`);
    
    legend.append('circle')
      .attr('cx', 0)
      .attr('cy', 0)
      .attr('r', 4)
      .attr('fill', 'gray')
      .attr('opacity', 0.5);
    
    legend.append('text')
      .attr('x', 10)
      .attr('y', 4)
      .text('Actual');
    
    legend.append('line')
      .attr('x1', -10)
      .attr('x2', 5)
      .attr('y1', 20)
      .attr('y2', 20)
      .attr('stroke', 'red')
      .attr('stroke-width', 2);
    
    legend.append('text')
      .attr('x', 10)
      .attr('y', 24)
      .text('Predicted');
    
    container.appendChild(svg.node());
  }

  // Initialize
  document.addEventListener('DOMContentLoaded', function() {
    // Load data
    initializeData();
    
    // Set up training button
    document.getElementById('trainButton').addEventListener('click', trainNetwork);
    
    // Train network with default parameters
    trainNetwork();
  });
</script>
</section>
</section>
<section id="statistical-models-vs.-machine-learning-models" class="level2">
<h2 class="anchored" data-anchor-id="statistical-models-vs.-machine-learning-models">Statistical Models vs.&nbsp;Machine Learning Models</h2>
<p>We assume most engineers, a priori, consider <em>machine learning</em> models as somehow ‘better’ than statistical models. In reality there is a <em>lot</em> of overlap between them, and the situation should dictate the model selection. However, since we assume the reader will inevitably be interested in machine learning, we think it’s best to include it, at the very least so we can understand the similarities and differences when compared to statistical models.</p>
<p>The discussion below gives differences we believe are <em>typically</em> true. However, in topics with as much overlap as statistics and machine learning, virtual no difference is definite.</p>
<section id="probabilistic-vs-deterministic-outputs" class="level3">
<h3 class="anchored" data-anchor-id="probabilistic-vs-deterministic-outputs">Probabilistic vs Deterministic Outputs</h3>
<p>A statistical model is built on probability distributions and can typically generate random data that accurately reflects its underlying statistical properties. A machine learning model <em>may</em> be built on probability distributions, and further, <em>may</em> be able to generate random data that accurately reflects its underlying statistical properties.</p>
</section>
<section id="likelihood-vs-loss-function" class="level3">
<h3 class="anchored" data-anchor-id="likelihood-vs-loss-function">Likelihood vs Loss Function</h3>
<p>Although these topics are effectively left for the second half of the primer, we’ll mention the following as it is an important difference:</p>
<ul>
<li>Statistical model parameters are optimized via a likelihood function based in probability theory</li>
<li>Machine learning model parameters are optimized using an objective/<strong>loss function</strong></li>
</ul>
<p>The confusing thing is that machine learning may have loss functions that use likelihood - but the key is they <em>do not have to</em>.</p>
</section>
<section id="volume-of-data-and-number-of-parameters" class="level3">
<h3 class="anchored" data-anchor-id="volume-of-data-and-number-of-parameters">Volume of Data and Number of Parameters</h3>
<p>There are other common differences that are even more blurry - like that machine learning is focused on larger datasets and often have more flexible (i.e.&nbsp;more parameters) methods. This tends to also mean overfitting is a larger concern in machine learning. You would also typically not define a causal model as a foundation for a machine learning model, as they tend to use predefined algorithms.</p>
</section>
</section>
<section id="neural-nets" class="level2">
<h2 class="anchored" data-anchor-id="neural-nets">Neural Nets</h2>
<p>There are many machine learning models we could focus on, however, we’ll choose Neural Nets, culminating in Bayesian Neural Nets…</p>
</section>
<section id="single-neuron" class="level2">
<h2 class="anchored" data-anchor-id="single-neuron">Single Neuron</h2>
<p>It’s helpful to focus on a single neuron before buildings up the rest of a neural net. First it will show an artificial neuron is not complicated. And second, discussing a single neuron allows for simple notation. When we need to keep track of many neurons, the notation required is a bit more complicated.</p>
<p>A neuron has a number of connections feeding into it, this is very much like the different inputs into a linear regression equation that we would label as <span class="math inline">\(x_1\)</span>, <span class="math inline">\(x_2\)</span> etc. Using familiar <strong>regression notation</strong> it would look like this:</p>
<p><span class="math display">\[
z = \beta_1x_1 + \beta_2x_2 + … + \beta_nx_n + \beta_0
\]</span></p>
<p>However, the neural net folks prefer something more akin to the following <strong>neural network notation</strong>:</p>
<p><span class="math display">\[
z = w_1a_1 + w_2a_2 + … + w_na_n + b
\]</span></p>
<p>Where we call <span class="math inline">\(w\)</span> a weight, <span class="math inline">\(a\)</span> an activation (since it’s usually from the previous neuron), and <span class="math inline">\(b\)</span> the bias.</p>
<section id="activation-function" class="level3">
<h3 class="anchored" data-anchor-id="activation-function">Activation Function</h3>
<p>There’s one more step in that some <strong>activation function</strong> is applied to <span class="math inline">\(z\)</span>, which is quite similar in form to generalized linear regression, although the purpose is only to introduce a convenient form of non-linearity.</p>
<p><span class="math display">\[
a = f(z)
\]</span></p>
<p>Where <span class="math inline">\(f(z)\)</span> is some activation function, which could be the sigmoid function we’ve already seen, among other options. Although not preferred in most large neural networks, the 0 to 1 range of the sigmoid function has a nice interpretation as the physical activation of the neuron.</p>
<p>As a reminder here is what the sigmoid activation looks like:</p>
<p><span class="math display">\[
\sigma(z) = \frac{1}{1 + e^{-z}}
\]</span></p>
</section>
</section>
<section id="neural-net-structure" class="level2">
<h2 class="anchored" data-anchor-id="neural-net-structure">Neural Net Structure</h2>
<p>Although there are many variations, a basic neural net consists of layers of artificial neurons that are activated based the outputs of the previous layer of neurons. An example will make this much more obvious.</p>
<p>To explain that further it helps immensely to have a diagram that points out the layers, the neurons, and what connections are being used to feed information into the next neuron.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
  %% Define classes with desired styles
  classDef inputLayer fill:#f9ebc2,stroke:#d6a000;
  classDef hiddenLayer1 fill:#c2ebf9,stroke:#0096d6;
  classDef hiddenLayer2 fill:#d8c2f9,stroke:#6a00d6;
  classDef outputLayer fill:#c2f9c9,stroke:#00d640;

  subgraph Input Layer
    N1(["$$N^{(0)}_{1}$$"])
    class N1 inputLayer;
  end

  subgraph Hidden Layer 1
    N2(["$$N^{(1)}_{1}$$"])
    N3(["$$N^{(1)}_{2}$$"])
    N4(["$$N^{(1)}_{3}$$"])
    class N2,N3,N4 hiddenLayer1;
  end

  subgraph Hidden Layer 2
    N5(["$$N^{(2)}_{1}$$"])
    N6(["$$N^{(2)}_{2}$$"])
    N7(["$$N^{(2)}_{3}$$"])
    class N5,N6,N7 hiddenLayer2;
  end

  subgraph Output Layer
    N8(["$$N^{(3)}_{1}$$"])
    class N8 outputLayer;
  end

  N1 --&gt;|"$$a^{(0)}_{1,1}$$"| N2
  N1 --&gt;|"$$a^{(0)}_{1,2}$$"| N3
  N1 --&gt;|"$$a^{(0)}_{1,3}$$"| N4
  
  N2 --&gt;|"$$a^{(1)}_{1,1}$$"| N5
  N2 --&gt;|"$$a^{(1)}_{1,2}$$"| N6
  N2 --&gt;|"$$a^{(1)}_{1,3}$$"| N7
  
  N3 --&gt;|"$$a^{(1)}_{2,1}$$"| N5
  N3 --&gt;|"$$a^{(1)}_{2,2}$$"| N6
  N3 --&gt;|"$$a^{(1)}_{2,3}$$"| N7
  
  N4 --&gt;|"$$a^{(1)}_{3,1}$$"| N5
  N4 --&gt;|"$$a^{(1)}_{3,2}$$"| N6
  N4 --&gt;|"$$a^{(1)}_{3,3}$$"| N7
  
  N5 --&gt;|"$$a^{(2)}_{1,1}$$"| N8
  N6 --&gt;|"$$a^{(2)}_{2,1}$$"| N8
  N7 --&gt;|"$$a^{(2)}_{3,1}$$"| N8
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>The number of input neurons match the number of variables (or dimensions) of the data we want to input. We are going to input one variable (the size/carats of a diamond) so we only need one input neuron.</p>
<p>We want the input and output functions to match the scale of our data (which can be greater than one), while we want the hidden layers to mimic the activation of a neuron (0% to 100%, or 0 to 1). Thus the inputs and outputs of our neural network will be based on linear regression, while the neurons in the hidden layers will be based on logistic regression.</p>
<section id="notation" class="level3">
<h3 class="anchored" data-anchor-id="notation">Notation</h3>
<p>The building blocks of a neural net are nothing scary, however there are a lot of pieces, and therefore a lot to keep track of. This demands some notation to keep everything straight, which is probably the scariest bit. (We should mention training a neural net is another tough part, but we will not worry about that here).</p>
<p>Since the working of modern large neural nets is intricately tied to matrix multiplication, the standard descriptions involve matrix notation. We are not interested in large neural nets so we will alter the standard notation to remove the matrix notation for the rest of us mere mortals.</p>
<p>We have the following natural heirarchy of information:</p>
<ul>
<li>Layers
<ul>
<li>Neurons
<ul>
<li>Weights</li>
<li>Bias</li>
<li>Activations</li>
</ul></li>
</ul></li>
</ul>
<section id="neurons" class="level4">
<h4 class="anchored" data-anchor-id="neurons">Neurons</h4>
<p>We can use the following notation to refer to a specific neuron <span class="math inline">\(N\)</span>:</p>
<p><span class="math inline">\(N^{(l)}_{i}\)</span></p>
<ul>
<li><span class="math inline">\(l\)</span> (superscript), the layer index/number</li>
<li><span class="math inline">\(i\)</span> (subscript),the neuron index/number within layer <span class="math inline">\(l\)</span></li>
</ul>
</section>
<section id="weights" class="level4">
<h4 class="anchored" data-anchor-id="weights">Weights</h4>
<p>We can use the following notation to refer to a specific weight <span class="math inline">\(w\)</span>:</p>
<p><span class="math inline">\(w^{(l)}_{i,j}\)</span></p>
<ul>
<li><span class="math inline">\(l\)</span> (superscript), the layer index/number</li>
<li><span class="math inline">\(i\)</span> (subscript), the neuron index/number within layer <span class="math inline">\(l\)</span></li>
<li><span class="math inline">\(j\)</span> (subscript), the weight index/number within neuron <span class="math inline">\(i\)</span></li>
</ul>
</section>
<section id="biases" class="level4">
<h4 class="anchored" data-anchor-id="biases">Biases</h4>
<p>We can use the following notation to refer to a specific bias <span class="math inline">\(b\)</span>:</p>
<p><span class="math inline">\(b^{(l)}_{i,j}\)</span></p>
<ul>
<li><span class="math inline">\(l\)</span> (superscript), the layer index/number</li>
<li><span class="math inline">\(i\)</span> (subscript), the neuron index/number within layer <span class="math inline">\(l\)</span></li>
<li><span class="math inline">\(j\)</span> (subscript), the bias index/number within neuron <span class="math inline">\(i\)</span></li>
</ul>
</section>
<section id="activations" class="level4">
<h4 class="anchored" data-anchor-id="activations">Activations</h4>
<p>We can use the following notation to refer to a specific activation <span class="math inline">\(a\)</span>:</p>
<p><span class="math inline">\(a^{(l)}_{i,j}\)</span></p>
<ul>
<li><span class="math inline">\(l\)</span> (superscript), the layer index/number</li>
<li><span class="math inline">\(i\)</span> (subscript), the neuron index/number within layer <span class="math inline">\(l\)</span></li>
<li><span class="math inline">\(j\)</span> (subscript), the activation index/number within neuron <span class="math inline">\(i\)</span></li>
</ul>
</section>
</section>
<section id="the-input-layer" class="level3">
<h3 class="anchored" data-anchor-id="the-input-layer">The Input Layer</h3>
<p>The first neuron, <span class="math inline">\(N^{(0)}_{1}\)</span>, takes one input and creates three unique outputs based on the following calculation, where <span class="math inline">\(w\)</span> is a weight/coefficient, <span class="math inline">\(x\)</span> is the input value (i.e.&nbsp;carats), and <span class="math inline">\(b\)</span> is a bias/intercept:</p>
<p><span class="math display">\[
\begin{aligned}
a^{(0)}_{1,1} &amp;= w^{(0)}_{1,1} \cdot x \;+\; b^{(0)}_{1,1}, \\
a^{(0)}_{1,2} &amp;= w^{(0)}_{1,2} \cdot x \;+\; b^{(0)}_{1,2}, \\
a^{(0)}_{1,3} &amp;= w^{(0)}_{1,3} \cdot x \;+\; b^{(0)}_{1,3}.
\end{aligned}
\]</span></p>
<p>Shown on a subset of the graph:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
  %% Define classes with desired styles
  classDef inputLayer fill:#f9ebc2,stroke:#d6a000;
  classDef hiddenLayer1 fill:#c2ebf9,stroke:#0096d6;

  subgraph Input Layer
    N1(["$$N^{(0)}_{1}$$"])
    class N1 inputLayer;
  end

  subgraph Hidden Layer 1
    N2(["$$N^{(1)}_{1}$$"])
    N3(["$$N^{(1)}_{2}$$"])
    N4(["$$N^{(1)}_{3}$$"])
    class N2,N3,N4 hiddenLayer1;
  end

  N1 --&gt;|"$$a^{(0)}_{1,1} = w^{(0)}_{1,1} \cdot x \;+\; b^{(0)}_{1,1}$$"| N2
  N1 --&gt;|"$$a^{(0)}_{1,2} = w^{(0)}_{1,2} \cdot x \;+\; b^{(0)}_{1,2}$$"| N3
  N1 --&gt;|"$$a^{(0)}_{1,3} = w^{(0)}_{1,3} \cdot x \;+\; b^{(0)}_{1,3}$$"| N4
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<section id="hidden-layer-1" class="level4">
<h4 class="anchored" data-anchor-id="hidden-layer-1">Hidden Layer 1</h4>
<p>At Hidden Layer 1, each neuron is again receiving one input (an activation this time), and again creating three unique outputs. Since we are now within the hidden layers, the math is logistic regression instead of linear regression. We examine the calculation occuring at neuron <span class="math inline">\(N^{(1)}_{1}\)</span>. Here <span class="math inline">\(a^{(0)}_{1,1}\)</span> is the activation value received from neuron <span class="math inline">\(N^{(0)}_{1}\)</span>.</p>
<p><span class="math display">\[
\begin{aligned}
a^{(1)}_{1,1} &amp;= \frac{1}{1 + e^{-(w^{(1)}_{1,1} \cdot a^{(0)}_{1,1} + b^{(1)}_{1,1})}}, \\
a^{(1)}_{1,2} &amp;= \frac{1}{1 + e^{-(w^{(1)}_{1,2} \cdot a^{(0)}_{1,1} + b^{(1)}_{1,2})}}, \\
a^{(1)}_{1,3} &amp;= \frac{1}{1 + e^{-(w^{(1)}_{1,3} \cdot a^{(0)}_{1,1} + b^{(1)}_{1,3})}}.
\end{aligned}
\]</span></p>
<p>Shown on a subset of the graph:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
  %% Define classes with desired styles
  classDef hiddenLayer fill:#c2ebf9,stroke:#0096d6;   %% Blue
  classDef outputLayer fill:#d8c2f9,stroke:#6a00d6;   %% Purple

  subgraph Hidden Layer 1
    N2(["$$N^{(1)}_{1}$$"])
    class N2 hiddenLayer;
  end

  subgraph Hidden Layer 2
    O1(["$$N^{(2)}_{1}$$"])
    O2(["$$N^{(2)}_{2}$$"])
    O3(["$$N^{(2)}_{3}$$"])
    class O1,O2,O3 outputLayer;
  end

  N2 --&gt;|"$$a^{(1)}_{1,1} = \frac{1}{1 + e^{-(w^{(1)}_{1,1} \cdot a^{(0)}_{1,1}  + b^{(1)}_{1,1})}}$$"| O1
  N2 --&gt;|"$$a^{(1)}_{1,2} =\frac{1}{1 + e^{-(w^{(1)}_{1,2} \cdot a^{(0)}_{1,1}  + b^{(1)}_{1,2}}}$$"| O2
  N2 --&gt;|"$$a^{(1)}_{1,3} =\frac{1}{1 + e^{-(w^{(1)}_{1,3} \cdot a^{(0)}_{1,1}  + b^{(1)}_{1,3})}}$$"| O3
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="hidden-layer-2" class="level4">
<h4 class="anchored" data-anchor-id="hidden-layer-2">Hidden Layer 2</h4>
<p>At Hidden Layer 2 each neuron takes the values from the first hidden layer of neurons and performs another logistic regression to determine its activation. If we examine neuron <span class="math inline">\(N^{(2)}_{1}\)</span>, it is taking in data from activation <span class="math inline">\(a^{(1)}_{1,1}\)</span>, <span class="math inline">\(a^{(1)}_{2,1}\)</span>, and <span class="math inline">\(a^{(1)}_{3,1}\)</span>, and then creating a single output, <span class="math inline">\(a^{(2)}_{1,1}\)</span>.</p>
<p><span class="math display">\[
a^{(2)}_{1,1} = \frac{1}{1 + e^{-(w^{(2)}_{1,1} \cdot a^{(1)}_{1,1} + w^{(2)}_{1,2} \cdot a^{(1)}_{2,1} + w^{(2)}_{1,3} \cdot a^{(1)}_{3,1} + b^{(2)}_{1,1})}}
\]</span></p>
<p>Shown on a subset of the graph:</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
  %% Define classes with desired styles
  classDef hiddenLayer fill:#d8c2f9,stroke:#6a00d6;
  classDef outputLayer fill:#c2f9c9,stroke:#00d640;

  subgraph Hidden Layer 2 Neuron
    N5(["$$N^{(2)}_{1}$$"])
    class N5 hiddenLayer;
  end

  subgraph Output
    O1(["$$N^{(3)}_{1}$$"])
    class O1 outputLayer;
  end

  N5 --&gt;|"$$\frac{1}{1 + e^{-(w^{(2)}_{1,1} \cdot a^{(1)}_{1,1} + w^{(2)}_{1,2} \cdot a^{(1)}_{2,1} + w^{(2)}_{1,3} \cdot a^{(1)}_{3,1} + b^{(2)}_{1,1})}}$$"| O1
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
</section>
<section id="the-output-layer" class="level4">
<h4 class="anchored" data-anchor-id="the-output-layer">The Output Layer</h4>
<p>The output neuron <span class="math inline">\(N^{(3)}_{1,1}\)</span> receives the activations <span class="math inline">\(a^{(2)}_{1,1}\)</span>, <span class="math inline">\(a^{(2)}_{2,1}\)</span>, and <span class="math inline">\(a^{(2)}_{3,1}\)</span> and uses linear regression to obtain the output value of the neural net.</p>
<p><span class="math display">\[
y = w^{(3)}_{1,1} \cdot a^{(2)}_{1,1} + w^{(3)}_{1,2} \cdot a^{(2)}_{2,1} + w^{(3)}_{1,3} \cdot a^{(2)}_{3,1} + b^{(3)}_{1,1}
\]</span></p>
</section>
<section id="values-of-weights-and-biases" class="level4">
<h4 class="anchored" data-anchor-id="values-of-weights-and-biases">Values of Weights and Biases</h4>
<p>While the structure of a neural net influences the types of problems it is most appropriate for, the knowledge of the neural net is held in the weights and biases. Determining the weights of a neural network is generally accomplished by training on data via backpropogation, for which numerous resources are available elsewhere. Here, we will jump past the details of that step so that we can proceed with a reasonably trained neural net…</p>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>