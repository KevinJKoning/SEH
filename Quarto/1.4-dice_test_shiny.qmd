---
title: Shiny Live Dice Example
format: html
filters:
  - shinylive
---

## Intro/Overview

We start *assuming* that we know the process generating the data we examine. In reality we usually have only clues, however, we start here as it allows us to quickly examine the probability/likelihood of the data generated by the process. Once we have a good understanding of probability/likelihood, it will allow us to work in 'reverse' and to use the data to estimate the properties/parameters of the data generating process.

The process is summarized in @fig-process.

```{mermaid}
//| label: fig-process
//| fig-cap: "Statistical Process"

%%{init: {'theme':'neutral'}}%%
graph TB
    A["Data Generation"] -->|Likelihood \n of Data| B["Data"]
    B -->|Likelihood of \n Data Generation| A
```


## Data Generation Dice Example

We'd prefer not to spend too much time on toy examples, however, there are a lot of benefits to starting with something that is intuitive and simple. Subsequently we'll use rolling dice as our first example of a data generating process.

Play around with the two inputs/parameters of the dice rolling app below, the number of dice and the number of rolls. Note how a larger number of rolls seems to give us smoother and more consistent results.

Please note it usually takes about 10 seconds for the app below to load.

```{shinylive-python}
#| standalone: true
#| viewerHeight: 550

from shiny import App, ui, render, reactive
import numpy as np
import matplotlib.pyplot as plt

app_ui = ui.page_fluid(
    ui.h2("Dice Rolling Demo"),
    ui.layout_sidebar(
        ui.sidebar(
            ui.input_slider("numDice", "Number of Dice", min=1, max=10, value=2, step=1),
            ui.input_slider("numRolls", "Number of Rolls", min=1, max=10000, value=100, step=1),
        ),
        ui.output_plot("dicePlot", height="400px"),
    ),
)

def server(input, output, session):
    # Define a reactive calculation that depends on numDice and numRolls
    @reactive.Calc
    def dice_sums():
        return [
            np.random.randint(1, 7, input.numDice()).sum()
            for _ in range(input.numRolls())
        ]

    @output
    @render.plot
    def dicePlot():
        current_sums = dice_sums()
        fig, ax = plt.subplots()

        unique_sums, counts = np.unique(current_sums, return_counts=True)
        ax.bar([str(s) for s in unique_sums], counts, color="steelblue")

        ax.set_title("Frequency of Dice Totals")
        ax.set_xlabel("Dice Total")
        ax.set_ylabel("Frequency")
        plt.xticks(rotation=90)

        return fig

app = App(app_ui, server)
```


## Dice Likelihood

To find the probability/likelihood of an event in our data generating process of dice rolls, we simply need to add up the frequency of that event, say how often there was total of twelve, and divide that by the total number of events. For example if we saw a total of twelve in 40 out of 5,000 roll-totals, the probability of rolling twelve is approximately 40/5,000=0.0008.

Now I know you're smart, and you're saying to yourself, I can figure out the *exact* probability of rolling a certain dice total. Of course you can for this example - but you probably can't for more realistic examples, and we want to learn techiques that work well in reality. 

If you are concerned with the quality of our estimate, just rerun the data generating process and see if the outcome changes meaningfully - if it does, increase the number of times we run the data generating process until the output is stable.

## More Data Generating Processes (Probability Distributions)

When we change the data generating process, the distribution of outcomes changes. Some data generating processes are quite common, so humanity has named them and [mostly] standardized their inputs/parameters. These common data generating processes are called *probability distributions*.

A 'coin-flip' process produces the binomial distribution, although the binomial distribution also has the nice property of not requiring that the coin is fair. The Poisson distribution models a process that results in a count, like a coin flip, but it doesn't have an upper limit because there are not a fixed number of trials. An example of this is a failure count, we can specify a rate at which failures occur, and typically observe failure rates near this value, but there's no fixed maximum.

Additive processes will eventually create normal/gaussian distributions. It is why that distribution is so common in nature, and if interested in the details, research the Central Limit Theorem. If you hadn't noticed in the dice example, if you keep adding dice and enough rolls, the outcomes look awfully normal/gaussian. Of course not all processes interact in an additive way, if it tends to multiply instead, you'll get the log-normal distribution.

The point here is that each probability distribution is the basic form of:
A) Each data generating process has inherent characteristics
B) These characteristics determine the shape/frequency of the outcomes


## Normal/Gaussian Likelihood

Hopefully it was fairly intuitive how to find the likelihood of a certain dice-total. One advantage of that data generating process is the outcomes were discrete - a total of nine, for example is one discrete outcome. Many data generating processes produce continuous outcomes. One example is height.

**Likelihood app**

A simple way to understand the likelihood of a continuous process is to bin the values to certain ranges. Say heights of less than 4 feet, 4-5 feet, 5-6 feet, and 6-7 feet, and more than 7 feet. You can then use the same basic counting techniques we used earlier - how many outcomes are in the 5-6 feet bin, and divide that by the total number of outcomes. For example, the 5-6 feet bin may occur 740/1,000 times, for an approximate probability of 0.74.

It will be useful for us to also estimate the probability density of exact values in continuous distributions...

## Likelihood of Multiple Events

So far we only considered the probability/likelihood of a single outcome, however, we are often interested in the probability of multiple outcomes.

**Equation for multiple outcomes, and the useful alternative of log-probabilty**

When determining the likelihood of multiple outcomes, there is an incredibly important assumption - that each event is [mostly] independent of each other. Perfect independence is rarely achieved, but as long as the correlations are not particularly strong, they are commonly ignored. In practice though, a common situation of not having independent events is the data in a time-series, do not assume independence in time-series data.

This is also a lesson in statistics in general, although the approach outlined here tries to limit the need for assumptions, many traditional statistical approaches have assumptions hidden underneath, and a very common one is that some aspect of the data is normally distributed. BE CAREFUL OF ASSUMPTIONS.

## Statistical Tests

Traditional statistical education is somewhat obsessed with testing if two data generating processes are different. (Our approach not only allows for determining if two data generating processes are different, but also making predictions about future data from the process). A common example of these 'significance' tests is a human's likelihood of dying while taking a medication vs not taking the medication. Obviously we prefer not to give people medications that are ineffective.

The typical approach goes something like this - if I assume I know the characteristics of data generating process A, and I know the data generated by a possibly different data generating process we'll call A/B - then how likely is the data, or even more extreme data/values, to come from A. If it is very unlikely to come from A, we'll conclude it is coming from another process, B.

That probably sounded somewhat confusing, and if you are confused, you are in good company. Many intelligent people publishing smart papers in reputable journals get the significance testing wrong, not to mention the arbitrary standard of rejecting a null hypothesis if p < 0.05, which should also be adjusted to the situation. Subsequently this text will spend no time on hypothesis testing, other than to say if it's important for you to determine if two data generating processes are different, I'm sure you can devise a method that makes sense and you can understand.

## Arbitrarily Complicated Processes

We are not limited to simple processes that create known probability distributions...

It is worth noting that a small number of parameters is generally called 'Statistics', and modest to large number of parameters is called 'Machine Learning', and somewhere around a billion or more it is called 'Artificial Intelligence'.

## Parameters

End with a discussion of parameters as they appear in probability distributions. Next we will move on to estimating these parameters in the second half of the book.