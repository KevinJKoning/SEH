{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: Naive Monte Carlo\n",
        "format: html\n",
        "filters:\n",
        "  - shinylive\n",
        "---\n",
        "\n",
        "\n",
        "## Intro\n",
        "\n",
        "We use the term *naive* to distinguish this method from more advanced Monte Carlo methods. The advantage here will be simplicity, but it will not be a good solution with many parameters (due to the spareseness of high dimensional space), or where we do not have good priors.\n",
        "\n",
        "::: callout-note\n",
        "If you're wondering why generate data for examples instead of using 'real' data sets, it's because it's the only way to have certainty in the data generating process. This allows us to see how well we fit the model. Obviously the goal is real data - but unfortunately you'll probably never know *exactly* what the data generating process was, and that makes understanding the accuracy of 'new' methods very difficult. \n",
        ":::\n",
        "\n",
        "## Bayesian Methods\n",
        "\n",
        "For determining the $P(M|D)$, we will use Bayesian methods. There's a whole historical debate you could research, but when it comes to most scientific and engineering subjects, you wouldn't be studying the subject if you didn't have some prior information, even if you can only describe it as intuition. This prior information is valuable, and it should be included in the model. Priors are also valueable in more bespoke models due to their ability to limit solutions to those known to be plausible... \n",
        "\n",
        "Allen Downey said it well when he stated in *Think Bayes* that if don't have much data you should use Bayesian methods, and when you have lots of data, it dominates the priors so you can still use Bayesian methods... (research the real quote).\n",
        "\n",
        "\n",
        "## Dataset\n"
      ],
      "id": "e7052d24"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "from scipy.stats import norm\n",
        "\n",
        "# Set random seed for reproducibility\n",
        "np.random.seed(42)\n",
        "\n",
        "# =========================\n",
        "# Step 1: Generate Data\n",
        "# =========================\n",
        "\n",
        "# True parameters\n",
        "mu_true = 5.5  # average height in feet\n",
        "sigma_true = 0.3  # standard deviation in feet\n",
        "\n",
        "# Generate dataset of 100 persons\n",
        "dataset_size = 100\n",
        "heights = np.random.normal(loc=mu_true, scale=sigma_true, size=dataset_size)\n",
        "\n",
        "# Plot the generated heights\n",
        "plt.figure(figsize=(10, 6))\n",
        "sns.histplot(heights, bins=15, kde=True, color='skyblue')\n",
        "plt.title('Histogram of Generated Heights (100 Persons)')\n",
        "plt.xlabel('Height (feet)')\n",
        "plt.ylabel('Frequency')\n",
        "plt.show()"
      ],
      "id": "6096b17d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Priors\n"
      ],
      "id": "8cd5bcbb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# =========================\n",
        "# Step 2: Define Priors (Corrected)\n",
        "# =========================\n",
        "\n",
        "# Define prior ranges\n",
        "mu_prior_min = 4.0  # feet\n",
        "mu_prior_max = 7.0  # feet\n",
        "sigma_prior_min = 0.0\n",
        "sigma_prior_max = 3 * sigma_true  # 0.9 feet\n",
        "\n",
        "# Plot the prior distributions\n",
        "fig, ax = plt.subplots(1, 2, figsize=(14, 5))\n",
        "\n",
        "# Prior for mu\n",
        "mu_values = np.linspace(mu_prior_min, mu_prior_max, 1000)\n",
        "mu_prior = np.ones_like(mu_values) / (mu_prior_max - mu_prior_min)\n",
        "ax[0].plot(mu_values, mu_prior, color='blue')\n",
        "ax[0].set_title(r'Prior Distribution for $\\mu$ (Mean Height)')\n",
        "ax[0].set_xlabel(r'$\\mu$ (feet)')\n",
        "ax[0].set_ylabel('Probability Density')\n",
        "\n",
        "# Prior for sigma\n",
        "sigma_values = np.linspace(sigma_prior_min, sigma_prior_max, 1000)\n",
        "sigma_prior_dist = np.ones_like(sigma_values) / (sigma_prior_max - sigma_prior_min)\n",
        "ax[1].plot(sigma_values, sigma_prior_dist, color='green')\n",
        "ax[1].set_title(r'Prior Distribution for $\\sigma$ (Std Dev)')\n",
        "ax[1].set_xlabel(r'$\\sigma$ (feet)')\n",
        "ax[1].set_ylabel('Probability Density')\n",
        "\n",
        "plt.show()"
      ],
      "id": "b35c7c42",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# =========================\n",
        "# Step 3: Sample from Priors\n",
        "# =========================\n",
        "\n",
        "# Number of samples\n",
        "num_prior_samples = 10000\n",
        "\n",
        "# Sample mu and sigma from their priors\n",
        "mu_samples = np.random.uniform(mu_prior_min, mu_prior_max, num_prior_samples)\n",
        "sigma_samples = np.random.uniform(sigma_prior_min, sigma_prior_max, num_prior_samples)\n",
        "\n",
        "# To avoid sigma=0, set a minimum sigma\n",
        "sigma_samples[sigma_samples == 0] = 1e-6\n",
        "\n",
        "# Generate heights based on sampled mu and sigma\n",
        "heights_prior = np.random.normal(loc=mu_samples, scale=sigma_samples)\n",
        "\n",
        "# Plot the prior-generated heights\n",
        "plt.figure(figsize=(10, 6))\n",
        "sns.histplot(heights_prior, bins=50, kde=True, color='orange')\n",
        "plt.title('Histogram of Heights Generated from Priors (10,000 Persons)')\n",
        "plt.xlabel('Height (feet)')\n",
        "plt.ylabel('Frequency')\n",
        "plt.show()"
      ],
      "id": "c78d3fa6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# =========================\n",
        "# Step 4: Naive Monte Carlo (Corrected)\n",
        "# =========================\n",
        "\n",
        "import pandas as pd\n",
        "\n",
        "# Precompute constants\n",
        "n = len(heights)\n",
        "data = heights\n",
        "\n",
        "# Vectorized computation of log-likelihoods\n",
        "# There's a hell of a lot happening in this one line. For each of the 10,000 random samples\n",
        "# from the prior, it is using each as the loc and scale of a norm dist to find the \n",
        "# likelihood of getting the height data. Then summing the 100 to get a 10,000 lenth array\n",
        "log_likelihoods = norm.logpdf(data[:, np.newaxis], loc=mu_samples, scale=sigma_samples).sum(axis=0)\n",
        "\n",
        "# To prevent numerical underflow, we'll work with log-likelihoods\n",
        "# Normalize log-likelihoods by subtracting the max\n",
        "max_log_likelihood = np.max(log_likelihoods)\n",
        "normalized_log_likelihood = log_likelihoods - max_log_likelihood\n",
        "likelihoods = np.exp(normalized_log_likelihood)\n",
        "\n",
        "# Compute posterior probabilities (unnormalized)\n",
        "# Due to flat priors posterior is just equivalent to the likelihoods\n",
        "posterior = likelihoods\n",
        "\n",
        "# Normalize the posterior (so it sums to 1)\n",
        "posterior /= np.sum(posterior)\n",
        "\n",
        "# Verify that 'posterior' is one-dimensional\n",
        "print(f\"Shape of posterior: {posterior.shape}\")\n",
        "\n",
        "# Create a DataFrame for easier handling\n",
        "df = pd.DataFrame({\n",
        "    'mu': mu_samples,\n",
        "    'sigma': sigma_samples,\n",
        "    'posterior': posterior\n",
        "})\n",
        "\n",
        "# Plot the posterior distributions for mu and sigma using Seaborn\n",
        "fig, ax = plt.subplots(1, 2, figsize=(14, 5))\n",
        "\n",
        "# Plot posterior for mu\n",
        "sns.histplot(data=df, x='mu', weights='posterior', bins=50, kde=True, color='purple', ax=ax[0])\n",
        "ax[0].axvline(mu_true, color='red', linestyle='--', label=r'True $\\mu$')\n",
        "ax[0].set_title(r'Posterior Distribution for $\\mu$')\n",
        "ax[0].set_xlabel(r'$\\mu$ (feet)')\n",
        "ax[0].set_ylabel('Posterior Probability')\n",
        "ax[0].legend()\n",
        "\n",
        "# Plot posterior for sigma\n",
        "sns.histplot(data=df, x='sigma', weights='posterior', bins=50, kde=True, color='brown', ax=ax[1])\n",
        "ax[1].axvline(sigma_true, color='red', linestyle='--', label=r'True $\\sigma$')\n",
        "ax[1].set_title(r'Posterior Distribution for $\\sigma$')\n",
        "ax[1].set_xlabel(r'$\\sigma$ (feet)')\n",
        "ax[1].set_ylabel('Posterior Probability')\n",
        "ax[1].legend()\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ],
      "id": "f9d36742",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# =========================\n",
        "# Step 5: Visualize Parameter Likelihood (Log-Scaled Color)\n",
        "# =========================\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "import numpy as np\n",
        "\n",
        "# Define a small epsilon to avoid log(0)\n",
        "epsilon = 1e-10\n",
        "\n",
        "# Compute the logarithm of posterior probabilities\n",
        "log_posterior = np.log(posterior + epsilon)\n",
        "\n",
        "# Create the scatter plot\n",
        "plt.figure(figsize=(10, 8))\n",
        "\n",
        "# Scatter plot using log_posterior for color scaling\n",
        "scatter = plt.scatter(\n",
        "    mu_samples,\n",
        "    sigma_samples,\n",
        "    c=log_posterior,          # Use log-transformed posterior\n",
        "    cmap='viridis',\n",
        "    alpha=0.5,\n",
        "    s=10\n",
        ")\n",
        "\n",
        "# Add a colorbar with appropriate labeling\n",
        "cbar = plt.colorbar(scatter)\n",
        "cbar.set_label('Log Posterior Probability')\n",
        "\n",
        "# Add reference lines for true parameter values using raw strings\n",
        "plt.axvline(mu_true, color='red', linestyle='--', label=r'True $\\mu$')\n",
        "plt.axhline(sigma_true, color='blue', linestyle='--', label=r'True $\\sigma$')\n",
        "\n",
        "# Set plot titles and labels using raw strings\n",
        "plt.title(r'Posterior Probability of $\\mu$ and $\\sigma$ (Log Scale)')\n",
        "plt.xlabel(r'$\\mu$ (feet)')\n",
        "plt.ylabel(r'$\\sigma$ (feet)')\n",
        "\n",
        "# Add legend\n",
        "plt.legend()\n",
        "\n",
        "# Display the plot\n",
        "plt.show()"
      ],
      "id": "d9e4ebfe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Shiny Live!\n",
        "\n",
        "\n",
        "```{shinylive-python}\n",
        "#| standalone: true\n",
        "#| viewerHeight: 900\n",
        "\n",
        "from shiny import App, ui, render, reactive\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "from scipy.stats import norm\n",
        "import pandas as pd\n",
        "\n",
        "app_ui = ui.page_fluid(\n",
        "    ui.h2(\"Bayesian Inference of Heights\"),\n",
        "    ui.layout_sidebar(\n",
        "        ui.sidebar(\n",
        "            ui.h4(\"True Parameters\"),\n",
        "            ui.input_numeric(\n",
        "                \"mu_true\", \n",
        "                \"True Mean Height (μ_true) [feet]\", \n",
        "                value=5.5, \n",
        "                min=4.0, \n",
        "                max=7.0, \n",
        "                step=0.1\n",
        "            ),\n",
        "            ui.input_numeric(\n",
        "                \"sigma_true\", \n",
        "                \"True Std Dev (σ_true) [feet]\", \n",
        "                value=0.3, \n",
        "                min=0.1, \n",
        "                max=1.0, \n",
        "                step=0.05\n",
        "            ),\n",
        "            ui.hr(),\n",
        "            ui.h4(\"Dataset Generation\"),\n",
        "            ui.input_numeric(\n",
        "                \"dataset_size\", \n",
        "                \"Number of Persons\", \n",
        "                value=100, \n",
        "                min=10, \n",
        "                max=1000, \n",
        "                step=10\n",
        "            ),\n",
        "            ui.hr(),\n",
        "            ui.h4(\"Prior Ranges\"),\n",
        "            ui.input_numeric(\n",
        "                \"mu_prior_min\", \n",
        "                \"μ Prior Minimum [feet]\", \n",
        "                value=4.0, \n",
        "                min=0.0, \n",
        "                max=6.0, \n",
        "                step=0.1\n",
        "            ),\n",
        "            ui.input_numeric(\n",
        "                \"mu_prior_max\", \n",
        "                \"μ Prior Maximum [feet]\", \n",
        "                value=7.0, \n",
        "                min=5.0, \n",
        "                max=10.0, \n",
        "                step=0.1\n",
        "            ),\n",
        "            ui.input_numeric(\n",
        "                \"sigma_prior_min\", \n",
        "                \"σ Prior Minimum [feet]\", \n",
        "                value=0.0, \n",
        "                min=0.0, \n",
        "                max=1.0, \n",
        "                step=0.05\n",
        "            ),\n",
        "            ui.input_numeric(\n",
        "                \"sigma_prior_max\", \n",
        "                \"σ Prior Maximum [feet]\", \n",
        "                value=0.9, \n",
        "                min=0.5, \n",
        "                max=3.0, \n",
        "                step=0.1\n",
        "            ),\n",
        "            ui.hr(),\n",
        "            ui.h4(\"Sampling\"),\n",
        "            ui.input_numeric(\n",
        "                \"num_prior_samples\", \n",
        "                \"Number of Prior Samples\", \n",
        "                value=10000, \n",
        "                min=1000, \n",
        "                max=100000, \n",
        "                step=1000\n",
        "            ),\n",
        "        ),\n",
        "        ui.navset_tab(\n",
        "            ui.nav_panel(\"Generated Data\", ui.output_plot(\"generated_heights_plot\")),\n",
        "            ui.nav_panel(\"Prior Distributions\", ui.output_plot(\"prior_distributions_plot\")),\n",
        "            ui.nav_panel(\"Prior-Generated Heights\", ui.output_plot(\"prior_generated_heights_plot\")),\n",
        "            ui.nav_panel(\"Posterior Distributions\", ui.output_plot(\"posterior_distributions_plot\")),\n",
        "            ui.nav_panel(\"Parameter Scatter Plot\", ui.output_plot(\"parameter_scatter_plot\")),\n",
        "        )\n",
        "\n",
        "    )\n",
        ")\n",
        "\n",
        "def server(input, output, session):\n",
        "    # Reactive expression to generate dataset\n",
        "    @reactive.Calc\n",
        "    def heights():\n",
        "        np.random.seed(42)  # For reproducibility\n",
        "        mu = input.mu_true()\n",
        "        sigma = input.sigma_true()\n",
        "        size = input.dataset_size()\n",
        "        return np.random.normal(loc=mu, scale=sigma, size=size)\n",
        "    \n",
        "    # Reactive expressions for prior ranges\n",
        "    @reactive.Calc\n",
        "    def mu_prior_range():\n",
        "        return (input.mu_prior_min(), input.mu_prior_max())\n",
        "    \n",
        "    @reactive.Calc\n",
        "    def sigma_prior_range():\n",
        "        return (input.sigma_prior_min(), input.sigma_prior_max())\n",
        "    \n",
        "    # Reactive expression to sample from priors\n",
        "    @reactive.Calc\n",
        "    def prior_samples():\n",
        "        num_samples = input.num_prior_samples()\n",
        "        mu_min, mu_max = mu_prior_range()\n",
        "        sigma_min, sigma_max = sigma_prior_range()\n",
        "        \n",
        "        mu_samples = np.random.uniform(mu_min, mu_max, num_samples)\n",
        "        sigma_samples = np.random.uniform(sigma_min, sigma_max, num_samples)\n",
        "        # Avoid sigma=0\n",
        "        sigma_samples[sigma_samples == 0] = 1e-6\n",
        "        return mu_samples, sigma_samples\n",
        "    \n",
        "    # Reactive expression to generate heights from priors\n",
        "    @reactive.Calc\n",
        "    def heights_prior_samples():\n",
        "        mu_samples, sigma_samples = prior_samples()\n",
        "        return np.random.normal(loc=mu_samples, scale=sigma_samples)\n",
        "    \n",
        "    # Reactive expression to compute posterior\n",
        "    @reactive.Calc\n",
        "    def posterior():\n",
        "        data = heights()\n",
        "        mu_samples, sigma_samples = prior_samples()\n",
        "        n = len(data)\n",
        "        \n",
        "        # Compute log-likelihoods\n",
        "        log_likelihoods = norm.logpdf(data[:, np.newaxis], loc=mu_samples, scale=sigma_samples).sum(axis=0)\n",
        "        \n",
        "        # Normalize log-likelihoods to prevent underflow\n",
        "        max_log_likelihood = np.max(log_likelihoods)\n",
        "        normalized_log_likelihood = log_likelihoods - max_log_likelihood\n",
        "        likelihoods = np.exp(normalized_log_likelihood)\n",
        "        \n",
        "        # Posterior probabilities (unnormalized)\n",
        "        posterior_probs = likelihoods\n",
        "        \n",
        "        # Normalize posterior\n",
        "        posterior_probs /= np.sum(posterior_probs)\n",
        "        \n",
        "        return posterior_probs\n",
        "    \n",
        "    # Reactive expression to create DataFrame for posterior\n",
        "    @reactive.Calc\n",
        "    def posterior_df():\n",
        "        mu_samples, sigma_samples = prior_samples()\n",
        "        posterior_probs = posterior()\n",
        "        return pd.DataFrame({\n",
        "            'mu': mu_samples,\n",
        "            'sigma': sigma_samples,\n",
        "            'posterior': posterior_probs\n",
        "        })\n",
        "    \n",
        "    # Plot 1: Generated Heights Histogram\n",
        "    @output\n",
        "    @render.plot\n",
        "    def generated_heights_plot():\n",
        "        data = heights()\n",
        "        plt.figure(figsize=(8, 5))\n",
        "        sns.histplot(data, bins=15, kde=True, color='skyblue')\n",
        "        plt.title(f'Histogram of Generated Heights ({input.dataset_size()} Persons)')\n",
        "        plt.xlabel('Height (feet)')\n",
        "        plt.ylabel('Frequency')\n",
        "        plt.tight_layout()\n",
        "        return plt.gcf()\n",
        "    \n",
        "    # Plot 2: Prior Distributions for mu and sigma\n",
        "    @output\n",
        "    @render.plot\n",
        "    def prior_distributions_plot():\n",
        "        mu_min, mu_max = mu_prior_range()\n",
        "        sigma_min, sigma_max = sigma_prior_range()\n",
        "        \n",
        "        fig, ax = plt.subplots(1, 2, figsize=(14, 5))\n",
        "        \n",
        "        # Prior for mu\n",
        "        mu_values = np.linspace(mu_min, mu_max, 1000)\n",
        "        mu_prior = np.ones_like(mu_values) / (mu_max - mu_min)\n",
        "        ax[0].plot(mu_values, mu_prior, color='blue')\n",
        "        ax[0].set_title(r'Prior Distribution for $\\mu$ (Mean Height)')\n",
        "        ax[0].set_xlabel(r'$\\mu$ (feet)')\n",
        "        ax[0].set_ylabel('Probability Density')\n",
        "        \n",
        "        # Prior for sigma\n",
        "        sigma_values = np.linspace(sigma_min, sigma_max, 1000)\n",
        "        sigma_prior_dist = np.ones_like(sigma_values) / (sigma_max - sigma_min)\n",
        "        ax[1].plot(sigma_values, sigma_prior_dist, color='green')\n",
        "        ax[1].set_title(r'Prior Distribution for $\\sigma$ (Std Dev)')\n",
        "        ax[1].set_xlabel(r'$\\sigma$ (feet)')\n",
        "        ax[1].set_ylabel('Probability Density')\n",
        "        \n",
        "        plt.tight_layout()\n",
        "        return plt.gcf()\n",
        "    \n",
        "    # Plot 3: Heights Generated from Priors\n",
        "    @output\n",
        "    @render.plot\n",
        "    def prior_generated_heights_plot():\n",
        "        heights_prior = heights_prior_samples()\n",
        "        plt.figure(figsize=(8, 5))\n",
        "        sns.histplot(heights_prior, bins=50, kde=True, color='orange')\n",
        "        plt.title(f'Histogram of Heights Generated from Priors ({input.num_prior_samples()} Persons)')\n",
        "        plt.xlabel('Height (feet)')\n",
        "        plt.ylabel('Frequency')\n",
        "        plt.tight_layout()\n",
        "        return plt.gcf()\n",
        "    \n",
        "    # Plot 4: Posterior Distributions for mu and sigma\n",
        "    @output\n",
        "    @render.plot\n",
        "    def posterior_distributions_plot():\n",
        "        df = posterior_df()\n",
        "        mu_true = input.mu_true()\n",
        "        sigma_true = input.sigma_true()\n",
        "        \n",
        "        fig, ax = plt.subplots(1, 2, figsize=(14, 5))\n",
        "        \n",
        "        # Posterior for mu\n",
        "        sns.histplot(data=df, x='mu', weights='posterior', bins=50, kde=True, color='purple', ax=ax[0])\n",
        "        ax[0].axvline(mu_true, color='red', linestyle='--', label=r'True $\\mu$')\n",
        "        ax[0].set_title(r'Posterior Distribution for $\\mu$')\n",
        "        ax[0].set_xlabel(r'$\\mu$ (feet)')\n",
        "        ax[0].set_ylabel('Posterior Probability')\n",
        "        ax[0].legend()\n",
        "        \n",
        "        # Posterior for sigma\n",
        "        sns.histplot(data=df, x='sigma', weights='posterior', bins=50, kde=True, color='brown', ax=ax[1])\n",
        "        ax[1].axvline(sigma_true, color='red', linestyle='--', label=r'True $\\sigma$')\n",
        "        ax[1].set_title(r'Posterior Distribution for $\\sigma$')\n",
        "        ax[1].set_xlabel(r'$\\sigma$ (feet)')\n",
        "        ax[1].set_ylabel('Posterior Probability')\n",
        "        ax[1].legend()\n",
        "        \n",
        "        plt.tight_layout()\n",
        "        return plt.gcf()\n",
        "    \n",
        "    # Plot 5: Scatter Plot of mu vs sigma with Log Posterior Probability\n",
        "    @output\n",
        "    @render.plot\n",
        "    def parameter_scatter_plot():\n",
        "        df = posterior_df()\n",
        "        mu_true = input.mu_true()\n",
        "        sigma_true = input.sigma_true()\n",
        "        \n",
        "        epsilon = 1e-10  # To avoid log(0)\n",
        "        log_posterior = np.log(df['posterior'] + epsilon)\n",
        "        \n",
        "        plt.figure(figsize=(10, 8))\n",
        "        scatter = plt.scatter(\n",
        "            df['mu'],\n",
        "            df['sigma'],\n",
        "            c=log_posterior,\n",
        "            cmap='viridis',\n",
        "            alpha=0.5,\n",
        "            s=10\n",
        "        )\n",
        "        cbar = plt.colorbar(scatter)\n",
        "        cbar.set_label('Log Posterior Probability')\n",
        "        \n",
        "        plt.axvline(mu_true, color='red', linestyle='--', label=r'True $\\mu$')\n",
        "        plt.axhline(sigma_true, color='blue', linestyle='--', label=r'True $\\sigma$')\n",
        "        \n",
        "        plt.title(r'Posterior Probability of $\\mu$ and $\\sigma$ (Log Scale)')\n",
        "        plt.xlabel(r'$\\mu$ (feet)')\n",
        "        plt.ylabel(r'$\\sigma$ (feet)')\n",
        "        plt.legend()\n",
        "        plt.tight_layout()\n",
        "        return plt.gcf()\n",
        "\n",
        "app = App(app_ui, server)\n",
        "```\n",
        "\n",
        "v2\n",
        "\n",
        "```{shinylive-python}\n",
        "#| standalone: true\n",
        "#| viewerHeight: 900\n",
        "\n",
        "from shiny import App, ui, render, reactive\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "from scipy.stats import norm\n",
        "import pandas as pd\n",
        "\n",
        "app_ui = ui.page_fluid(\n",
        "    ui.h2(\"Bayesian Inference of Heights\"),\n",
        "    ui.row(\n",
        "        ui.column(3,\n",
        "            ui.h4(\"True Parameters\"),\n",
        "            ui.input_numeric(\n",
        "                \"mu_true\", \n",
        "                \"True Mean Height [feet]\", \n",
        "                value=5.5, \n",
        "                min=4.0, \n",
        "                max=7.0, \n",
        "                step=0.1\n",
        "            ),\n",
        "            ui.input_numeric(\n",
        "                \"sigma_true\", \n",
        "                \"True Std Dev (σ_true) [feet]\", \n",
        "                value=0.3, \n",
        "                min=0.1, \n",
        "                max=1.0, \n",
        "                step=0.05\n",
        "            ),\n",
        "        ),\n",
        "        ui.column(3,\n",
        "            ui.h4(\"Dataset Generation\"),\n",
        "            ui.input_numeric(\n",
        "                \"dataset_size\", \n",
        "                \"Number of Persons\", \n",
        "                value=100, \n",
        "                min=10, \n",
        "                max=1000, \n",
        "                step=10\n",
        "            ),\n",
        "        ),\n",
        "        ui.column(3,\n",
        "            ui.h4(\"Prior Ranges\"),\n",
        "            ui.input_numeric(\n",
        "                \"mu_prior_min\", \n",
        "                \"μ Prior Minimum [feet]\", \n",
        "                value=4.0, \n",
        "                min=0.0, \n",
        "                max=6.0, \n",
        "                step=0.1\n",
        "            ),\n",
        "            ui.input_numeric(\n",
        "                \"mu_prior_max\", \n",
        "                \"μ Prior Maximum [feet]\", \n",
        "                value=7.0, \n",
        "                min=5.0, \n",
        "                max=10.0, \n",
        "                step=0.1\n",
        "            ),\n",
        "        ),\n",
        "        ui.column(3,\n",
        "            ui.h4(\"Prior Ranges & Sampling\"),\n",
        "            ui.input_numeric(\n",
        "                \"sigma_prior_min\", \n",
        "                \"σ Prior Minimum [feet]\", \n",
        "                value=0.0, \n",
        "                min=0.0, \n",
        "                max=1.0, \n",
        "                step=0.05\n",
        "            ),\n",
        "            ui.input_numeric(\n",
        "                \"sigma_prior_max\", \n",
        "                \"σ Prior Maximum [feet]\", \n",
        "                value=0.9, \n",
        "                min=0.5, \n",
        "                max=3.0, \n",
        "                step=0.1\n",
        "            ),\n",
        "            ui.input_numeric(\n",
        "                \"num_prior_samples\", \n",
        "                \"Number of Prior Samples\", \n",
        "                value=10000, \n",
        "                min=1000, \n",
        "                max=100000, \n",
        "                step=1000\n",
        "            ),\n",
        "        )\n",
        "    ),\n",
        "    ui.navset_tab(\n",
        "        ui.nav_panel(\"True Height Data\", ui.output_plot(\"generated_heights_plot\")),\n",
        "        ui.nav_panel(\"Prior\", ui.output_plot(\"prior_distributions_plot\")),\n",
        "        ui.nav_panel(\"Prior-Generated Heights\", ui.output_plot(\"prior_generated_heights_plot\")),\n",
        "        ui.nav_panel(\"Posterior\", ui.output_plot(\"posterior_distributions_plot\")),\n",
        "        ui.nav_panel(\"Parameter Plot\", ui.output_plot(\"parameter_scatter_plot\")),\n",
        "    )\n",
        ")\n",
        "\n",
        "\n",
        "def server(input, output, session):\n",
        "    # Reactive expression to generate dataset\n",
        "    @reactive.Calc\n",
        "    def heights():\n",
        "        np.random.seed(42)  # For reproducibility\n",
        "        mu = input.mu_true()\n",
        "        sigma = input.sigma_true()\n",
        "        size = input.dataset_size()\n",
        "        return np.random.normal(loc=mu, scale=sigma, size=size)\n",
        "    \n",
        "    # Reactive expressions for prior ranges\n",
        "    @reactive.Calc\n",
        "    def mu_prior_range():\n",
        "        return (input.mu_prior_min(), input.mu_prior_max())\n",
        "    \n",
        "    @reactive.Calc\n",
        "    def sigma_prior_range():\n",
        "        return (input.sigma_prior_min(), input.sigma_prior_max())\n",
        "    \n",
        "    # Reactive expression to sample from priors\n",
        "    @reactive.Calc\n",
        "    def prior_samples():\n",
        "        num_samples = input.num_prior_samples()\n",
        "        mu_min, mu_max = mu_prior_range()\n",
        "        sigma_min, sigma_max = sigma_prior_range()\n",
        "        \n",
        "        mu_samples = np.random.uniform(mu_min, mu_max, num_samples)\n",
        "        sigma_samples = np.random.uniform(sigma_min, sigma_max, num_samples)\n",
        "        # Avoid sigma=0\n",
        "        sigma_samples[sigma_samples == 0] = 1e-6\n",
        "        return mu_samples, sigma_samples\n",
        "    \n",
        "    # Reactive expression to generate heights from priors\n",
        "    @reactive.Calc\n",
        "    def heights_prior_samples():\n",
        "        mu_samples, sigma_samples = prior_samples()\n",
        "        return np.random.normal(loc=mu_samples, scale=sigma_samples)\n",
        "    \n",
        "    # Reactive expression to compute posterior\n",
        "    @reactive.Calc\n",
        "    def posterior():\n",
        "        data = heights()\n",
        "        mu_samples, sigma_samples = prior_samples()\n",
        "        n = len(data)\n",
        "        \n",
        "        # Compute log-likelihoods\n",
        "        log_likelihoods = norm.logpdf(data[:, np.newaxis], loc=mu_samples, scale=sigma_samples).sum(axis=0)\n",
        "        \n",
        "        # Normalize log-likelihoods to prevent underflow\n",
        "        max_log_likelihood = np.max(log_likelihoods)\n",
        "        normalized_log_likelihood = log_likelihoods - max_log_likelihood\n",
        "        likelihoods = np.exp(normalized_log_likelihood)\n",
        "        \n",
        "        # Posterior probabilities (unnormalized)\n",
        "        posterior_probs = likelihoods\n",
        "        \n",
        "        # Normalize posterior\n",
        "        posterior_probs /= np.sum(posterior_probs)\n",
        "        \n",
        "        return posterior_probs\n",
        "    \n",
        "    # Reactive expression to create DataFrame for posterior\n",
        "    @reactive.Calc\n",
        "    def posterior_df():\n",
        "        mu_samples, sigma_samples = prior_samples()\n",
        "        posterior_probs = posterior()\n",
        "        return pd.DataFrame({\n",
        "            'mu': mu_samples,\n",
        "            'sigma': sigma_samples,\n",
        "            'posterior': posterior_probs\n",
        "        })\n",
        "    \n",
        "    # Plot 1: Generated Heights Histogram\n",
        "    @output\n",
        "    @render.plot\n",
        "    def generated_heights_plot():\n",
        "        data = heights()\n",
        "        plt.figure(figsize=(8, 5))\n",
        "        sns.histplot(data, bins=15, kde=True, color='skyblue')\n",
        "        plt.title(f'Histogram of Generated Heights ({input.dataset_size()} Persons)')\n",
        "        plt.xlabel('Height (feet)')\n",
        "        plt.ylabel('Frequency')\n",
        "        plt.tight_layout()\n",
        "        return plt.gcf()\n",
        "    \n",
        "    # Plot 2: Prior Distributions for mu and sigma\n",
        "    @output\n",
        "    @render.plot\n",
        "    def prior_distributions_plot():\n",
        "        mu_min, mu_max = mu_prior_range()\n",
        "        sigma_min, sigma_max = sigma_prior_range()\n",
        "        \n",
        "        fig, ax = plt.subplots(1, 2, figsize=(14, 5))\n",
        "        \n",
        "        # Prior for mu\n",
        "        mu_values = np.linspace(mu_min, mu_max, 1000)\n",
        "        mu_prior = np.ones_like(mu_values) / (mu_max - mu_min)\n",
        "        ax[0].plot(mu_values, mu_prior, color='blue')\n",
        "        ax[0].set_title(r'Prior Distribution for $\\mu$ (Mean Height)')\n",
        "        ax[0].set_xlabel(r'$\\mu$ (feet)')\n",
        "        ax[0].set_ylabel('Probability Density')\n",
        "        \n",
        "        # Prior for sigma\n",
        "        sigma_values = np.linspace(sigma_min, sigma_max, 1000)\n",
        "        sigma_prior_dist = np.ones_like(sigma_values) / (sigma_max - sigma_min)\n",
        "        ax[1].plot(sigma_values, sigma_prior_dist, color='green')\n",
        "        ax[1].set_title(r'Prior Distribution for $\\sigma$ (Std Dev)')\n",
        "        ax[1].set_xlabel(r'$\\sigma$ (feet)')\n",
        "        ax[1].set_ylabel('Probability Density')\n",
        "        \n",
        "        plt.tight_layout()\n",
        "        return plt.gcf()\n",
        "    \n",
        "    # Plot 3: Heights Generated from Priors\n",
        "    @output\n",
        "    @render.plot\n",
        "    def prior_generated_heights_plot():\n",
        "        heights_prior = heights_prior_samples()\n",
        "        plt.figure(figsize=(8, 5))\n",
        "        sns.histplot(heights_prior, bins=50, kde=True, color='orange')\n",
        "        plt.title(f'Histogram of Heights Generated from Priors ({input.num_prior_samples()} Persons)')\n",
        "        plt.xlabel('Height (feet)')\n",
        "        plt.ylabel('Frequency')\n",
        "        plt.tight_layout()\n",
        "        return plt.gcf()\n",
        "    \n",
        "    # Plot 4: Posterior Distributions for mu and sigma\n",
        "    @output\n",
        "    @render.plot\n",
        "    def posterior_distributions_plot():\n",
        "        df = posterior_df()\n",
        "        mu_true = input.mu_true()\n",
        "        sigma_true = input.sigma_true()\n",
        "        \n",
        "        fig, ax = plt.subplots(1, 2, figsize=(14, 5))\n",
        "        \n",
        "        # Posterior for mu\n",
        "        sns.histplot(data=df, x='mu', weights='posterior', bins=50, kde=True, color='purple', ax=ax[0])\n",
        "        ax[0].axvline(mu_true, color='red', linestyle='--', label=r'True $\\mu$')\n",
        "        ax[0].set_title(r'Posterior Distribution for $\\mu$')\n",
        "        ax[0].set_xlabel(r'$\\mu$ (feet)')\n",
        "        ax[0].set_ylabel('Posterior Probability')\n",
        "        ax[0].legend()\n",
        "        \n",
        "        # Posterior for sigma\n",
        "        sns.histplot(data=df, x='sigma', weights='posterior', bins=50, kde=True, color='brown', ax=ax[1])\n",
        "        ax[1].axvline(sigma_true, color='red', linestyle='--', label=r'True $\\sigma$')\n",
        "        ax[1].set_title(r'Posterior Distribution for $\\sigma$')\n",
        "        ax[1].set_xlabel(r'$\\sigma$ (feet)')\n",
        "        ax[1].set_ylabel('Posterior Probability')\n",
        "        ax[1].legend()\n",
        "        \n",
        "        plt.tight_layout()\n",
        "        return plt.gcf()\n",
        "    \n",
        "    # Plot 5: Scatter Plot of mu vs sigma with Log Posterior Probability\n",
        "    @output\n",
        "    @render.plot\n",
        "    def parameter_scatter_plot():\n",
        "        df = posterior_df()\n",
        "        mu_true = input.mu_true()\n",
        "        sigma_true = input.sigma_true()\n",
        "        \n",
        "        epsilon = 1e-10  # To avoid log(0)\n",
        "        log_posterior = np.log(df['posterior'] + epsilon)\n",
        "        \n",
        "        plt.figure(figsize=(10, 8))\n",
        "        scatter = plt.scatter(\n",
        "            df['mu'],\n",
        "            df['sigma'],\n",
        "            c=log_posterior,\n",
        "            cmap='viridis',\n",
        "            alpha=0.5,\n",
        "            s=10\n",
        "        )\n",
        "        cbar = plt.colorbar(scatter)\n",
        "        cbar.set_label('Log Posterior Probability')\n",
        "        \n",
        "        plt.axvline(mu_true, color='red', linestyle='--', label=r'True $\\mu$')\n",
        "        plt.axhline(sigma_true, color='blue', linestyle='--', label=r'True $\\sigma$')\n",
        "        \n",
        "        plt.title(r'Posterior Probability of $\\mu$ and $\\sigma$ (Log Scale)')\n",
        "        plt.xlabel(r'$\\mu$ (feet)')\n",
        "        plt.ylabel(r'$\\sigma$ (feet)')\n",
        "        plt.legend()\n",
        "        plt.tight_layout()\n",
        "        return plt.gcf()\n",
        "\n",
        "app = App(app_ui, server)\n",
        "```\n",
        "\n",
        "\n",
        "## Less Naive Monte Carlo\n",
        "\n",
        "If you paid attention to the Posterior Probability of $\\mu$ and $\\sigma$ plot, you probabiliy noticed that a *lot* of the points/space on the chart was consumed by areas of low probability. This was true even though we had few parameters (low dimensions) and good priors. The trick of the more advanced Monte Carlo techniques is how to find the areas of high likelihood and sample them efficiently. These include Hamiltonian Monte Carlo (HMC) and the No-U-Turn Sampler (NUTS). We'll use em, and thankfully the details are easily researched if you want to know more...\n"
      ],
      "id": "b23dcf72"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "/home/codespace/.local/share/jupyter/kernels/python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}